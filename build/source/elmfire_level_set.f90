! *****************************************************************************
MODULE ELMFIRE_LEVEL_SET
! *****************************************************************************

USE ELMFIRE_SPOTTING
USE ELMFIRE_SPOTTING_SUPERSEDED
USE ELMFIRE_IO
USE ELMFIRE_SUBS
USE ELMFIRE_SUPPRESSION
USE ELMFIRE_SPREAD_RATE
USE ELMFIRE_VARS

IMPLICIT NONE

CONTAINS

! *****************************************************************************
SUBROUTINE LEVEL_SET_PROPAGATION(IWX_BAND,ICASE,NTIMESTEPS)
! *****************************************************************************

! INTENT(IN) and INTENT(OUT) variables:
INTEGER, INTENT(IN) :: IWX_BAND, ICASE
INTEGER, INTENT(OUT) :: NTIMESTEPS

! Local variables & pointers:
INTEGER :: I, ILOC, J, IX, IY, ITIMESTEP, IX_IGN, IY_IGN, ISTEP, K, LU, IT1, IT2, &
           ITSTART, ITNOW, IDUMPCOUNT, ICOUNT, IXSTART, IYSTART, IXSTOP, IYSTOP, IX2, IY2, &
           ITLO_METEOROLOGY, ITHI_METEOROLOGY, BINARY_OUTPUTS_SIZE, IT_EA, IXCEN, IYCEN, IOS, IPYROME, &
           N_TO_TAG, N_SPOT_FIRES, ILH, IT2_LSP, IFBFM, IBLDGFM, ICOL, IROW
INTEGER, SAVE :: NX, NY, NDUMPS
INTEGER, POINTER, SAVE, DIMENSION(:) :: IX_TO_TAG, IY_TO_TAG, IX_SPOT_FIRE, IY_SPOT_FIRE

REAL :: T_LAST_EXTENDED_ATTACK, T_LAST_INTERPOLATE_M1, T_LAST_INTERPOLATE_M10, T_LAST_INTERPOLATE_M100, &
        T_LAST_INTERPOLATE_MLH, T_LAST_INTERPOLATE_MLW, T_LAST_INTERPOLATE_FMC, T_LAST_INTERPOLATE_WIND, &
        T_LAST_WIND_FLUCTUATIONS, T, DT, SURFACE_ACCELERATION_FACTOR, &
        F_METEOROLOGY, R0, TAU, ACRES, ACRES_SDI, ELAPSED_TIME, E, FLIN_MAX, HECTARES, POC, SIMULATION_TSTOP_HOURS, &
        BURN_PERIOD_CENTER_HOUR, BURN_PERIOD_START_HOUR, BURN_PERIOD_STOP_HOUR, HOUR_OF_DAY, DT_DAY, TBURN, &
        T_LAST_SMOKE_OUTPUT, QDOTNOW, XCEN, YCEN, THI, TLO, MDOTNOW, RADIUS, WN_FUEL, RUNTIME, T_TOTAL, P_IGNITION, HARDENING_FACTOR_LOCAL

REAL, SAVE :: ACRES_PER_PIXEL, DUMPTIMES(0:1000), RCELLSIZE, HALFRCELLSIZE, TSTOP, WS20
REAL, ALLOCATABLE, SAVE, DIMENSION(:) :: X,Y
REAL, POINTER, DIMENSION(:,:), SAVE :: M1_LO, M1_HI, M10_LO, M10_HI, M100_LO, M100_HI, WS20_LO, WS20_HI, &
                                       WD20_LO, WD20_HI, MLH_LO, MLH_HI, MLW_LO, MLW_HI, FMC_LO, FMC_HI
REAL, POINTER, SAVE, DIMENSION(:,:,:) :: A_TIMES_BURNED

LOGICAL :: IA_HAS_OCCURRED, LOPEN, GO, CALL_SPOTTING, JUST_INTERPOLATED, DUMP_SMOKE_OUTPUTS, RUN
LOGICAL, SAVE :: FIRSTCALL
LOGICAL, DIMENSION(1:100) :: ALREADY_IGNITED

REAL, ALLOCATABLE, DIMENSION(:,:) :: DYNAMIC_ARRAY  ! Dynamic array to store IX and IY

CHARACTER(4) :: FOUR_IWX_BAND, FOUR_IRANK_WORLD
CHARACTER(7) :: SEVEN_ICASE
CHARACTER(16) :: TIMESTAMP
CHARACTER(400) :: FN

TYPE(NODE), POINTER :: C, DUMMY_NODE => NULL()

TYPE (FUEL_MODEL_TABLE_TYPE) :: FMT

CALL SYSTEM_CLOCK(ITSTART)
IT1=ITSTART

IF (.NOT. ALLOCATED(PHIP)) FIRSTCALL = .TRUE.

IF (RANDOMIZE_SIMULATION_TSTOP) THEN
   CALL RANDOM_NUMBER(R0)
   TSTOP = SIMULATION_TSTART + R0 * (SIMULATION_TSTOP - SIMULATION_TSTART)
ELSE
   TSTOP = SIMULATION_TSTOP
ENDIF

IF (CSV_FIXED_IGNITION_LOCATIONS) THEN
   IF (STATS_TSTOP(ICASE) .GT. 0.) TSTOP = 3600. * STATS_TSTOP(ICASE)
ENDIF

SIMULATION_TSTOP_HOURS = -1.
STATS_SIMULATION_TSTOP_HOURS(ICASE) = SIMULATION_TSTOP_HOURS

IF (FIRSTCALL) THEN
   FIRSTCALL      = .FALSE.
   RCELLSIZE       = 1. / ANALYSIS_CELLSIZE
   HALFRCELLSIZE   = 0.5 * RCELLSIZE
   ACRES_PER_PIXEL = 2.47105E-4 * ANALYSIS_CELLSIZE*ANALYSIS_CELLSIZE
   NX              = ANALYSIS_NCOLS
   NY              = ANALYSIS_NROWS

   ALLOCATE(X(1:NX))
   ALLOCATE(Y(1:NY))
   ALLOCATE(IX_TO_TAG   (1:100000))
   ALLOCATE(IY_TO_TAG   (1:100000))
   IF (USE_UMD_SPOTTING_MODEL) THEN
      ALLOCATE(IX_SPOT_FIRE(1:NX*NY))
      ALLOCATE(IY_SPOT_FIRE(1:NX*NY))
   ELSE
      ALLOCATE(IX_SPOT_FIRE(1:100000))
      ALLOCATE(IY_SPOT_FIRE(1:100000))
   ENDIF
   
   X(1) = ANALYSIS_XLLCORNER + 0.5 * ANALYSIS_CELLSIZE
   DO IX = 2, NX
      X(IX) = X(IX-1) + ANALYSIS_CELLSIZE
   ENDDO

   Y(1) = ANALYSIS_YLLCORNER + 0.5 * ANALYSIS_CELLSIZE
   DO IY = 2, NY
      Y(IY) = Y(IY-1) + ANALYSIS_CELLSIZE
   ENDDO

! Determine when to dump:
   T = 0.
   IDUMPCOUNT = 0
   DUMPTIMES(:) = 9E9
   DUMPTIMES(0) = 0.
   DO WHILE (T .LE. TSTOP)
      T                     = T + DTDUMP
      IDUMPCOUNT            = IDUMPCOUNT + 1
      DUMPTIMES(IDUMPCOUNT) = T
   ENDDO
   NDUMPS = IDUMPCOUNT

   ALLOCATE(TIME_OF_ARRIVAL (1:NX,1:NY)); TIME_OF_ARRIVAL(:,:) = -1.
   ALLOCATE(EMBER_TIGN      (1:NX,1:NY)); EMBER_TIGN(:,:) = -1.
   ALLOCATE(T_LOCAL_IGNITION(1:NX,1:NY)); T_LOCAL_IGNITION(:,:) = -1
   ALLOCATE(LOCAL_IGNITION  (1:NX,1:NY)); LOCAL_IGNITION(:,:) = .FALSE.
   ALLOCATE(TAGGED          (1:NX,1:NY)); TAGGED(:,:) = .FALSE.
   ALLOCATE(PHIP            (1:NX,1:NY)); PHIP(:,:) = 1
   ALLOCATE(EVERTAGGED      (1:NX,1:NY)); EVERTAGGED(:,:) = .FALSE.
   ALLOCATE(EVERTAGGED_IX   (1:NX*NY))
   ALLOCATE(EVERTAGGED_IY   (1:NX*NY))

   BINARY_OUTPUTS_SIZE = NX*NY
   ALLOCATE(BINARY_OUTPUTS_IX           (1:BINARY_OUTPUTS_SIZE) )
   ALLOCATE(BINARY_OUTPUTS_IY           (1:BINARY_OUTPUTS_SIZE) )
   ALLOCATE(BINARY_OUTPUTS_TOA          (1:BINARY_OUTPUTS_SIZE) )
   ALLOCATE(BINARY_OUTPUTS_FLAME_LENGTH (1:BINARY_OUTPUTS_SIZE) )
   ALLOCATE(BINARY_OUTPUTS_VELOCITY_FPM (1:BINARY_OUTPUTS_SIZE) )
   ALLOCATE(BINARY_OUTPUTS_CROWN_FIRE   (1:BINARY_OUTPUTS_SIZE) )

   IF (USE_EMBER_COUNT_BINS) THEN
      ALLOCATE(EMBER_COUNT(1:NX,1:NY))
      EMBER_COUNT(:,:) = 0
   ENDIF

! Point pointers to analysis rasters:
   A_TIMES_BURNED => ANALYSIS_TIMES_BURNED%R4 (:,:,:)
   SURFACE_FIRE   => ANALYSIS_SURFACE_FIRE%I2(:,:,1); SURFACE_FIRE(:,:) = 0.

   IF (DUMP_EMBER_FLUX) EMBER_FLUX%R4(:,:,:) = 0
   IF (ENABLE_SPOTTING .AND. USE_UMD_SPOTTING_MODEL .AND. USE_EULERIAN_SPOTTING) EMBER_FLUX%R4(:,:,:) = 0

   WRITE(FOUR_IRANK_WORLD, '(I4.4)') IRANK_WORLD
   IF (NUM_TIME_AT_BURNED_ACRES .GT. 0) ALLOCATE(ALREADY_REACHED_BURNED_ACRES(1:NUM_TIME_AT_BURNED_ACRES))
      
   IF (PROCESS_TIMED_LOCATIONS) THEN
      DO I = 1, NUM_TIMED_LOCATIONS
         TIMED_LOCATIONS_TRACKER(I)%IX = ICOL_FROM_X(TIMED_LOCATIONS_TRACKER(I)%X,ANALYSIS_XLLCORNER,ANALYSIS_CELLSIZE)
         TIMED_LOCATIONS_TRACKER(I)%IY = IROW_FROM_Y(TIMED_LOCATIONS_TRACKER(I)%Y,ANALYSIS_YLLCORNER,ANALYSIS_CELLSIZE)
      ENDDO
   ENDIF

   IF (NUM_VIRTUAL_STATIONS .GT. 0) THEN
      LIST_VIRTUAL_STATIONS = NEW_DLL()
      DO I = 1, NUM_VIRTUAL_STATIONS
         VIRTUAL_STATION_IX(I) = ICOL_FROM_X(VIRTUAL_STATION_X(I),ANALYSIS_XLLCORNER,ANALYSIS_CELLSIZE)
         VIRTUAL_STATION_IY(I) = IROW_FROM_Y(VIRTUAL_STATION_Y(I),ANALYSIS_YLLCORNER,ANALYSIS_CELLSIZE)
         CALL APPEND(LIST_VIRTUAL_STATIONS,VIRTUAL_STATION_IX(I),VIRTUAL_STATION_IY(I),0.)
      ENDDO
   ENDIF

ENDIF !FIRSTCALL

CALL ACCUMULATE_CPU_USAGE(30, IT1, IT2)

WRITE(FOUR_IWX_BAND, '(I4.4)') IWX_BAND
WRITE(SEVEN_ICASE  , '(I7.7)') ICASE

T=SIMULATION_TSTART
IF (RANDOM_IGNITIONS) THEN
   IX_IGN = ICOL_FROM_X(STATS_X(ICASE),ANALYSIS_XLLCORNER,ANALYSIS_CELLSIZE)
   IY_IGN = IROW_FROM_Y(STATS_Y(ICASE),ANALYSIS_YLLCORNER,ANALYSIS_CELLSIZE)

   IF (USE_PYROMES .AND. CALIBRATION_CONSTANTS_BY_PYROME) THEN
      IPYROME = MIN(MAX(PYROMES%I2(IX_IGN,IY_IGN,1),1),128)
      IF (CALIBRATION_CONSTANTS_BY_PYROME) THEN
         INITIAL_ATTACK_TIME        = INITIAL_ATTACK_TIME_PYROME(IPYROME)
         B_SDI                      = B_SDI_PYROME(IPYROME)
         MAX_CONTAINMENT_PER_DAY    = MAX_CONTAINMENT_PER_DAY_PYROME(IPYROME)
         AREA_NO_CONTAINMENT_CHANGE = AREA_NO_CONTAINMENT_CHANGE_PYROME(IPYROME)

         IF (RANDOMIZE_SIMULATION_TSTOP) THEN
            CALL RANDOM_NUMBER(R0)
            TSTOP = SIMULATION_TSTART + R0 * (SIMULATION_DURATION_PYROME(IPYROME) - SIMULATION_TSTART)
         ELSE
            TSTOP = SIMULATION_DURATION_PYROME(IPYROME)
         ENDIF
      ENDIF
      IF (ADJUSTMENT_FACTORS_BY_PYROME) CROWN_FIRE_ADJ = ADJ_PYROME(IPYROME,0)
   ENDIF

   IF (USE_PYROMES .AND. DURATION_PDF_BY_PYROME) THEN
      IPYROME = MIN(MAX(PYROMES%I2(IX_IGN,IY_IGN,1),1),128)
      CALL RANDOM_NUMBER(R0)
      CALL LOCATE(DURATION_CDF_PYROME(IPYROME,:), DURATION_MAX_DAYS, R0, ILOC)
      ILOC = MAX(MIN(ILOC + 1, DURATION_MAX_DAYS),1)
      TSTOP = 86400.0 * REAL(ILOC)
   ENDIF

   IF (ISNONBURNABLE(IX_IGN,IY_IGN)) THEN
      STATS_SURFACE_FIRE_AREA          (ICASE) = 0. 
      STATS_CROWN_FIRE_AREA            (ICASE) = 0. 
      STATS_FIRE_VOLUME                (ICASE) = 0.
      STATS_AFFECTED_POPULATION        (ICASE) = 0.
      STATS_AFFECTED_REAL_ESTATE_VALUE (ICASE) = 0.
      STATS_AFFECTED_LAND_VALUE        (ICASE) = 0.
      STATS_FINAL_CONTAINMENT_FRAC     (ICASE) = 0.
      STATS_NEMBERS                    (ICASE) = 0.
      STATS_SIMULATION_TSTOP_HOURS     (ICASE) = -9999.
      STATS_PM2P5_RELEASE              (ICASE) = 0.
      STATS_HRR_PEAK                   (ICASE) = 0.
      RETURN
   ENDIF

ENDIF

! Check for errant IWX_BAND
RUN = .TRUE.

IF (IWX_BAND .LT. 1) THEN
   WRITE(*,*) 'CYCLING BECAUSE IWX_BAND .LT. 1: ', IWX_BAND
   RUN = .FALSE.
ENDIF 
          
IF (IWX_BAND + NUM_METEOROLOGY_TIMES - 1 .GT. WS%NBANDS) THEN
   WRITE(*,*) 'CYCLING BECAUSE IWX_BAND + NUM_METEOROLOGY_TIMES - 1 .GT. WS%NBANDS: ', IWX_BAND
   RUN = .FALSE.
ENDIF 

IF (.NOT. RUN) THEN
   STATS_SURFACE_FIRE_AREA          (ICASE) = 0. 
   STATS_CROWN_FIRE_AREA            (ICASE) = 0. 
   STATS_FIRE_VOLUME                (ICASE) = 0.
   STATS_AFFECTED_POPULATION        (ICASE) = 0.
   STATS_AFFECTED_REAL_ESTATE_VALUE (ICASE) = 0.
   STATS_AFFECTED_LAND_VALUE        (ICASE) = 0.
   STATS_FINAL_CONTAINMENT_FRAC     (ICASE) = 0.
   STATS_NEMBERS                    (ICASE) = 0.
   STATS_SIMULATION_TSTOP_HOURS     (ICASE) = -9999.
   STATS_PM2P5_RELEASE              (ICASE) = 0.
   STATS_HRR_PEAK                   (ICASE) = 0.
   RETURN
ENDIF

CALL ACCUMULATE_CPU_USAGE(31, IT1, IT2)

! Initialize viariables on each new call:
ITIMESTEP                   = 0
T_LAST_INTERPOLATE_M1       = -9E9
T_LAST_INTERPOLATE_M10      = -9E9
T_LAST_INTERPOLATE_M100     = -9E9
T_LAST_INTERPOLATE_MLH      = -9E9
T_LAST_INTERPOLATE_MLW      = -9E9
T_LAST_INTERPOLATE_FMC      = -9E9
T_LAST_INTERPOLATE_WIND     = -9E9
T_LAST_WIND_FLUCTUATIONS    = -9E9

T_LAST_SMOKE_OUTPUT         = -9E9

DT                          = SIMULATION_DT
SURFACE_ACCELERATION_FACTOR =  1.
ACRES                       = 0.
ACRES_SDI                   = 0.

LIST_TAGGED                 = NEW_DLL(); LIST_TAGGED%NUM_NODES=0
LIST_BURNED                 = NEW_DLL(); LIST_BURNED%NUM_NODES=0
LIST_SUPPRESSED             = NEW_DLL(); LIST_SUPPRESSED%NUM_NODES=0
NUM_EVERTAGGED              = 0

IA_HAS_OCCURRED             = .FALSE.
ALREADY_IGNITED(:)          = .FALSE.

NUM_TRACKED_EMBERS          = 0 ! Only used if USE_UMD_SPOTTING_MODEL = T

CALL ACCUMULATE_CPU_USAGE(32, IT1, IT2)

IF (ENABLE_EXTENDED_ATTACK) THEN
   DO IT_EA = 0, 1000
      SUPP(IT_EA)%NCELLS(:)=0
      SUPP(IT_EA)%VELOCITY(:)=0.
      SUPP(IT_EA)%VELOCITY_SMOOTHED(:)=0.
      SUPP(IT_EA)%FIRELINE_FRACTION(:)=0.
      SUPP(IT_EA)%SUPPRESSED_FRACTION(:)=0.
      SUPP(IT_EA)%T=0.
      SUPP(IT_EA)%ACRES=0.
      SUPP(IT_EA)%ACRES_SDI=0.
      SUPP(IT_EA)%TARGET_CONTAINMENT=0.
      SUPP(IT_EA)%DC_PER_DAY=0.
      SUPP(IT_EA)%DADT=0.
      SUPP(IT_EA)%DASDIDT=0.
      SUPP(IT_EA)%SDIBAR=0.
      SUPP(IT_EA)%IXCEN=0
      SUPP(IT_EA)%IYCEN=0
   ENDDO
ENDIF
IT_EA=0

CALL ACCUMULATE_CPU_USAGE(33, IT1, IT2)

IF (.NOT. RANDOM_IGNITIONS) PHIP(:,:) = PHI0%R4(:,:,1)

IF (DUMP_EMBER_FLUX .AND. (.NOT. ACCUMULATE_EMBER_FLUX) ) EMBER_FLUX%R4(:,:,:) = 0

! Tag bands where initial phi values are less than 0:
IF (.NOT. RANDOM_IGNITIONS) THEN
   ! Get initial wind information for nodes in LIST_BURNED, for spotting model
   ITLO_METEOROLOGY = 1
   ITHI_METEOROLOGY = 1
   F_METEOROLOGY = 1.
   
   M1_LO   => M1P   (:,:,ITLO_METEOROLOGY)
   M1_HI   => M1P   (:,:,ITHI_METEOROLOGY)
   M10_LO  => M10P  (:,:,ITLO_METEOROLOGY)
   M10_HI  => M10P  (:,:,ITHI_METEOROLOGY)
   M100_LO => M100P (:,:,ITLO_METEOROLOGY)
   M100_HI => M100P (:,:,ITHI_METEOROLOGY)
   WS20_LO => WSP   (:,:,ITLO_METEOROLOGY)
   WS20_HI => WSP   (:,:,ITHI_METEOROLOGY)
   WD20_LO => WDP   (:,:,ITLO_METEOROLOGY)
   WD20_HI => WDP   (:,:,ITHI_METEOROLOGY)
   MLH_LO  => MLHP  (:,:,ITLO_METEOROLOGY)
   MLH_HI  => MLHP  (:,:,ITHI_METEOROLOGY)
   MLW_LO  => MLWP  (:,:,ITLO_METEOROLOGY)
   MLW_HI  => MLWP  (:,:,ITHI_METEOROLOGY)
   FMC_LO  => MFOLP (:,:,ITLO_METEOROLOGY)
   FMC_HI  => MFOLP (:,:,ITHI_METEOROLOGY)

   ICOUNT=0
   DO IY = 1, NY
   DO IX = 1, NX
      IF (PHIP(IX,IY) .LE. 0.) THEN
         SURFACE_FIRE(IX,IY) = 1
         ACRES = ACRES + ACRES_PER_PIXEL
         TIME_OF_ARRIVAL(IX,IY) = MAX(0.,SIMULATION_TSTART)
         ICOUNT = ICOUNT + 1

         CALL APPEND(LIST_BURNED, IX, IY, T)

         IF (WX_BILINEAR_INTERPOLATION) THEN
            CALL INTERP_RASTER_LINKEDLIST_SINGLE_BILINEAR (LIST_BURNED%TAIL, M1_LO  (:,:), M1_HI  (:,:), F_METEOROLOGY, 1)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE_BILINEAR (LIST_BURNED%TAIL, M10_LO (:,:), M10_HI (:,:), F_METEOROLOGY, 2)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE_BILINEAR (LIST_BURNED%TAIL, M100_LO(:,:), M100_HI(:,:), F_METEOROLOGY, 3)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE_BILINEAR (LIST_BURNED%TAIL, MLH_LO (:,:), MLH_HI (:,:), F_METEOROLOGY, 4)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE_BILINEAR (LIST_BURNED%TAIL, MLW_LO (:,:), MLW_HI (:,:), F_METEOROLOGY, 5)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE_BILINEAR (LIST_BURNED%TAIL, FMC_LO (:,:), FMC_HI (:,:), F_METEOROLOGY, 6)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE_BILINEAR (LIST_BURNED%TAIL, WS20_LO(:,:), WS20_HI(:,:), F_METEOROLOGY, 7)
         ELSE
            CALL INTERP_RASTER_LINKEDLIST_SINGLE (LIST_BURNED%TAIL, M1_LO  (:,:), M1_HI  (:,:), F_METEOROLOGY, 1)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE (LIST_BURNED%TAIL, M10_LO (:,:), M10_HI (:,:), F_METEOROLOGY, 2)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE (LIST_BURNED%TAIL, M100_LO(:,:), M100_HI(:,:), F_METEOROLOGY, 3)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE (LIST_BURNED%TAIL, MLH_LO (:,:), MLH_HI (:,:), F_METEOROLOGY, 4)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE (LIST_BURNED%TAIL, MLW_LO (:,:), MLW_HI (:,:), F_METEOROLOGY, 5)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE (LIST_BURNED%TAIL, FMC_LO (:,:), FMC_HI (:,:), F_METEOROLOGY, 6)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE (LIST_BURNED%TAIL, WS20_LO(:,:), WS20_HI(:,:), F_METEOROLOGY, 7)
         ENDIF
         
         CALL INTERP_WD_RASTER_SINGLE(LIST_BURNED%TAIL, WD20_LO(:,:), WD20_HI(:,:), F_METEOROLOGY)

         ICOL = ICOL_ANALYSIS_F2C(IX)
         IROW = IROW_ANALYSIS_F2C(IY)
         LIST_BURNED%TAIL%TIME_OF_ARRIVAL        = T
         LIST_BURNED%TAIL%WS20_NOW               = WS20_LO(ICOL,IROW) * (1. - F_METEOROLOGY) + F_METEOROLOGY * WS20_HI(ICOL,IROW)
         LIST_BURNED%TAIL%TAU_EMBERGEN           = 0.
         LIST_BURNED%TAIL%BURNED                 = .FALSE.
         IF (USE_BLDG_SPREAD_MODEL) LIST_BURNED%TAIL%IBLDGFM =BLDG_FUEL_MODEL%I2(IX,IY,1)

         IF (USE_SDI) C%SDI = SDI_FACTOR * SDI%R4(ICOL,IROW,1)

!         IF (ENABLE_SMOKE_OUTPUTS) THEN
!            LIST_BURNED%TAIL%TIME_IGNITED = T
!            IF (C%VELOCITY .GT. 0.) THEN
!               TBURN = ASP%CELLSIZE / (C%VELOCITY * 0.3048 / 60.)
!            ELSE
!               TBURN = 30.0
!            ENDIF
!            TBURN = MIN(MAX(TBURN,1.),10800.0)
!            LIST_BURNED%TAIL%TIME_EXTINGUISHED = T + TBURN
!            LIST_BURNED%TAIL%HRRPUA = (C%FLIN_SURFACE + C%FLIN_CANOPY) / ASP%CELLSIZE ! Yiren: FLIN_SURFACE and FLIN_CANOPY seems asigned no value(0 and 0)
!         ENDIF

      ENDIF
   ENDDO
   ENDDO

   ! Call relevant functions, assign values to FLIN_SURFACE and FLIN_CANOPY
   NULLIFY(C) 
   CALL SURFACE_SPREAD_RATE(LIST_BURNED, C)

   ! Adjust spread rate for passive and active crown fire (Cruz):
   ! Note that this adjusts spread rate in not only burned cells but nearby cells
   ! that are "about to burn"
   IF (CROWN_FIRE_MODEL .GT. 0) CALL CROWN_SPREAD_RATE(LIST_TAGGED, C)
   DO ISTEP=1,2
      ! Calcaulate components of normal vector
      CALL CALC_NORMAL_VECTORS (ISTEP, HALFRCELLSIZE)

      ! Calculate x and y components of velocity from elliptical spread dimensions
      CALL UX_AND_UY_ELLIPTICAL(LIST_BURNED, LIST_BURNED, 1.0, ISTEP, T, DYNAMIC_ARRAY)
   ENDDO

   C => LIST_BURNED%HEAD
   DO I = 1, LIST_BURNED%NUM_NODES
      C%HRRPUA = (C%FLIN_SURFACE + C%FLIN_CANOPY) / ASP%CELLSIZE
      C%BURNED = .TRUE.
      C => C%NEXT
   ENDDO
   ! End call relevant functions, assign values to FLIN_SURFACE and FLIN_CANOPY

   IF (ENABLE_EXTENDED_ATTACK) SUPP(0)%ACRES = ACRES

   ICOUNT = 0
   DO IY = 1, NY
   DO IX = 1, NX

      IF (PHIP(IX,IY) .LE. 0.) THEN

         IXSTART = MAX(1 , IX - BANDTHICKNESS) ; IXSTART = MIN(IXSTART,NX)
         IXSTOP  = MIN(NX, IX + BANDTHICKNESS) ; IXSTOP  = MAX(IXSTOP , 1)
         IYSTART = MAX(1 , IY - BANDTHICKNESS) ; IYSTART = MIN(IYSTART,NY)
         IYSTOP  = MIN(NY, IY + BANDTHICKNESS) ; IYSTOP  = MAX(IYSTOP , 1)

         GO = .FALSE. 

         IF (IXSTOP .GE. IXSTART .AND. IYSTOP .GE. IYSTART) THEN
           DO IY2 = IYSTART, IYSTOP
           DO IX2 = IXSTART, IXSTOP
               IF (PHIP(IX2,IY2) .GT. 0.) GO = .TRUE. 
           ENDDO
           ENDDO
         ENDIF

         IF (GO .AND. (.NOT. ISNONBURNABLE(IX,IY)) ) THEN
            ICOUNT = ICOUNT + 1 
            CALL TAG_BAND(NX,NY,IX,IY,T)
         ENDIF
      ENDIF
   ENDDO
   ENDDO

ENDIF

CALL ACCUMULATE_CPU_USAGE(34, IT1, IT2)

IF (ENABLE_SMOKE_OUTPUTS) THEN
   DUMP_SMOKE_OUTPUTS = .FALSE.
   CALL RANDOM_NUMBER(R0)
   IF (R0 .LE. 0.01*SMOKE_OUTPUTS_DUMP_PERCENT) DUMP_SMOKE_OUTPUTS = .TRUE.
ENDIF

IF (NUM_TIME_AT_BURNED_ACRES .GT. 0) ALREADY_REACHED_BURNED_ACRES(:) = .FALSE.
   
! Begin main timestepping loop:
T = SIMULATION_TSTART
IDUMPCOUNT = 1

CALL ACCUMULATE_CPU_USAGE(35, IT1, IT2)

DO WHILE (T .LE. TSTOP .OR. IDUMPCOUNT .LE. NDUMPS)
   CALL SYSTEM_CLOCK(IT1)
   T = T + DT
   IF (T .LT. SIMULATION_TSTART) CYCLE

   ITIMESTEP = ITIMESTEP + 1

   IF (USE_DIURNAL_ADJUSTMENT_FACTOR) THEN

      BURN_PERIOD_CENTER_HOUR = SUNRISE_HOUR + BURN_PERIOD_CENTER_FRAC * (SUNSET_HOUR - SUNRISE_HOUR)
      BURN_PERIOD_START_HOUR  = BURN_PERIOD_CENTER_HOUR - 0.5 * BURN_PERIOD_LENGTH
      BURN_PERIOD_STOP_HOUR   = BURN_PERIOD_CENTER_HOUR + 0.5 * BURN_PERIOD_LENGTH
      IF (BURN_PERIOD_STOP_HOUR .GT. 24.) BURN_PERIOD_STOP_HOUR = BURN_PERIOD_STOP_HOUR - 24.

      HOUR_OF_DAY = FORECAST_START_HOUR + T / 3600.0
      HOUR_OF_DAY = MODULO(HOUR_OF_DAY, 24.)
      DIURNAL_ADJUSTMENT_FACTOR = 1.0
      IF (BURN_PERIOD_STOP_HOUR .GT. BURN_PERIOD_START_HOUR) THEN
         IF (HOUR_OF_DAY .LT. BURN_PERIOD_START_HOUR .OR. HOUR_OF_DAY .GT. BURN_PERIOD_STOP_HOUR) THEN
            DIURNAL_ADJUSTMENT_FACTOR = OVERNIGHT_ADJUSTMENT_FACTOR
         ENDIF
      ELSE
         IF (HOUR_OF_DAY .GT. BURN_PERIOD_STOP_HOUR .AND. HOUR_OF_DAY .LT. BURN_PERIOD_START_HOUR) THEN
            DIURNAL_ADJUSTMENT_FACTOR = OVERNIGHT_ADJUSTMENT_FACTOR
         ENDIF
      ENDIF

   ENDIF

   IF (RANDOM_IGNITIONS) THEN
      PHIP    (IX_IGN,IY_IGN) = -1.0
      IF (ITIMESTEP .EQ. 1) CALL TAG_BAND(NX,NY,IX_IGN,IY_IGN,T)
   ENDIF

   IF (NUM_IGNITIONS .GT. 0) THEN
      DO I = 1, NUM_IGNITIONS
         IF (ALREADY_IGNITED(I)) CYCLE
         IF (T .GE. T_IGN(I)) THEN
            ALREADY_IGNITED(I) = .TRUE.
            IX_IGN = ICOL_FROM_X(X_IGN(I),ANALYSIS_XLLCORNER,ANALYSIS_CELLSIZE)
            IY_IGN = IROW_FROM_Y(Y_IGN(I),ANALYSIS_YLLCORNER,ANALYSIS_CELLSIZE)
            CALL TAG_BAND(NX,NY,IX_IGN,IY_IGN,T)
            PHIP    (IX_IGN,IY_IGN) = -1.0
         ENDIF
      ENDDO
   ENDIF

   CALL ACCUMULATE_CPU_USAGE(36, IT1, IT2)

! Determine where we are in the wind and weather arrays::
   IF (ITIMESTEP .EQ. 1 .OR. NUM_METEOROLOGY_TIMES .GT. 1) THEN
      ITLO_METEOROLOGY = MAX(1 + FLOOR(T / DT_METEOROLOGY),1)
      ITLO_METEOROLOGY = MIN(ITLO_METEOROLOGY, NUM_METEOROLOGY_TIMES)
      ITHI_METEOROLOGY = MIN(ITLO_METEOROLOGY + 1, NUM_METEOROLOGY_TIMES)
      F_METEOROLOGY = (T - REAL(ITLO_METEOROLOGY-1) * DT_METEOROLOGY) / DT_METEOROLOGY
      IF (ITLO_METEOROLOGY .EQ. ITHI_METEOROLOGY) F_METEOROLOGY = 1.

      M1_LO   => M1P   (:,:,ITLO_METEOROLOGY)
      M1_HI   => M1P   (:,:,ITHI_METEOROLOGY)
      M10_LO  => M10P  (:,:,ITLO_METEOROLOGY)
      M10_HI  => M10P  (:,:,ITHI_METEOROLOGY)
      M100_LO => M100P (:,:,ITLO_METEOROLOGY)
      M100_HI => M100P (:,:,ITHI_METEOROLOGY)
      WS20_LO => WSP   (:,:,ITLO_METEOROLOGY)
      WS20_HI => WSP   (:,:,ITHI_METEOROLOGY)
      WD20_LO => WDP   (:,:,ITLO_METEOROLOGY)
      WD20_HI => WDP   (:,:,ITHI_METEOROLOGY)
      MLH_LO  => MLHP  (:,:,ITLO_METEOROLOGY)
      MLH_HI  => MLHP  (:,:,ITHI_METEOROLOGY)
      MLW_LO  => MLWP  (:,:,ITLO_METEOROLOGY)
      MLW_HI  => MLWP  (:,:,ITHI_METEOROLOGY)
      FMC_LO  => MFOLP (:,:,ITLO_METEOROLOGY)
      FMC_HI  => MFOLP (:,:,ITHI_METEOROLOGY)
   ENDIF

   IF (NUM_VIRTUAL_STATIONS .GT. 0) THEN
      C=>LIST_VIRTUAL_STATIONS%HEAD
      DO I = 1, NUM_VIRTUAL_STATIONS
         CALL INTERP_RASTER_LINKEDLIST_SINGLE (C, M1_LO  (:,:), M1_HI  (:,:), F_METEOROLOGY, 1)
         CALL INTERP_RASTER_LINKEDLIST_SINGLE (C, M10_LO (:,:), M10_HI (:,:), F_METEOROLOGY, 2)
         CALL INTERP_RASTER_LINKEDLIST_SINGLE (C, M100_LO(:,:), M100_HI(:,:), F_METEOROLOGY, 3)
         CALL INTERP_RASTER_LINKEDLIST_SINGLE (C, MLH_LO (:,:), MLH_HI (:,:), F_METEOROLOGY, 4)
         CALL INTERP_RASTER_LINKEDLIST_SINGLE (C, MLW_LO (:,:), MLW_HI (:,:), F_METEOROLOGY, 5)
         CALL INTERP_RASTER_LINKEDLIST_SINGLE (C, FMC_LO (:,:), FMC_HI (:,:), F_METEOROLOGY, 6)
         CALL INTERP_RASTER_LINKEDLIST_SINGLE (C, WS20_LO(:,:), WS20_HI(:,:), F_METEOROLOGY, 7)
         CALL INTERP_WD_RASTER_SINGLE(C, WD20_LO(:,:), WD20_HI(:,:), F_METEOROLOGY)
         CALL WRITE_STATION(C,IRANK_WORLD,ICASE,T)
         C=>C%NEXT
      ENDDO
   ENDIF

! If user-specified SURFACE_ACCELERATION_TIME_CONSTANT is greater than 30 seconds,
! calculate SURFACE_ACCELERATION_FACTOR:
   IF (SURFACE_ACCELERATION_TIME_CONSTANT .GT. 30.) THEN
      TAU = T / SURFACE_ACCELERATION_TIME_CONSTANT
      IF (TAU .GT. 7) THEN
         SURFACE_ACCELERATION_FACTOR = 1.000000
      ELSE
         SURFACE_ACCELERATION_FACTOR = 1.000000 - EXP(-TAU)
      ENDIF
   ENDIF
   
   CALL ACCUMULATE_CPU_USAGE(37, IT1, IT2)

! Interpolate / map transient weather rasters
   JUST_INTERPOLATED = .FALSE.
   
   IF (T - T_LAST_INTERPOLATE_M1 .GE. DT_INTERPOLATE_M1) THEN
      T_LAST_INTERPOLATE_M1 = T
      JUST_INTERPOLATED = .TRUE.
      IF (WX_BILINEAR_INTERPOLATION) THEN
         CALL INTERP_RASTER_LINKEDLIST_BILINEAR(LIST_TAGGED, M1_LO  (:,:), M1_HI  (:,:), F_METEOROLOGY, 1)
      ELSE
         CALL INTERP_RASTER_LINKEDLIST(LIST_TAGGED, M1_LO  (:,:), M1_HI  (:,:), F_METEOROLOGY, 1)
      ENDIF
   ENDIF

   IF (T - T_LAST_INTERPOLATE_M10 .GE. DT_INTERPOLATE_M10) THEN
      T_LAST_INTERPOLATE_M10 = T
      JUST_INTERPOLATED = .TRUE.
      IF (WX_BILINEAR_INTERPOLATION) THEN
         CALL INTERP_RASTER_LINKEDLIST_BILINEAR(LIST_TAGGED, M10_LO (:,:), M10_HI (:,:), F_METEOROLOGY, 2)
      ELSE
         CALL INTERP_RASTER_LINKEDLIST(LIST_TAGGED, M10_LO (:,:), M10_HI (:,:), F_METEOROLOGY, 2)
      ENDIF
   ENDIF

   IF (T - T_LAST_INTERPOLATE_M100 .GE. DT_INTERPOLATE_M100) THEN
      T_LAST_INTERPOLATE_M100 = T
      JUST_INTERPOLATED = .TRUE.
      IF (WX_BILINEAR_INTERPOLATION) THEN
         CALL INTERP_RASTER_LINKEDLIST_BILINEAR(LIST_TAGGED, M100_LO(:,:), M100_HI(:,:), F_METEOROLOGY, 3)
      ELSE
         CALL INTERP_RASTER_LINKEDLIST(LIST_TAGGED, M100_LO(:,:), M100_HI(:,:), F_METEOROLOGY, 3)
      ENDIF
   ENDIF

   IF (T - T_LAST_INTERPOLATE_MLH .GE. DT_INTERPOLATE_MLH) THEN
      T_LAST_INTERPOLATE_MLH = T
      JUST_INTERPOLATED = .TRUE.
      IF (WX_BILINEAR_INTERPOLATION) THEN
         CALL INTERP_RASTER_LINKEDLIST_BILINEAR(LIST_TAGGED, MLH_LO (:,:), MLH_HI (:,:), F_METEOROLOGY, 4)
      ELSE
         CALL INTERP_RASTER_LINKEDLIST(LIST_TAGGED, MLH_LO (:,:), MLH_HI (:,:), F_METEOROLOGY, 4)
      ENDIF
   ENDIF

   IF (T - T_LAST_INTERPOLATE_MLW .GE. DT_INTERPOLATE_MLW) THEN
      T_LAST_INTERPOLATE_MLW = T
      JUST_INTERPOLATED = .TRUE.
      IF (WX_BILINEAR_INTERPOLATION) THEN
         CALL INTERP_RASTER_LINKEDLIST_BILINEAR(LIST_TAGGED, MLW_LO (:,:), MLW_HI (:,:), F_METEOROLOGY, 5)
      ELSE
         CALL INTERP_RASTER_LINKEDLIST(LIST_TAGGED, MLW_LO (:,:), MLW_HI (:,:), F_METEOROLOGY, 5)
      ENDIF
   ENDIF

   IF (T - T_LAST_INTERPOLATE_FMC .GE. DT_INTERPOLATE_FMC) THEN
      T_LAST_INTERPOLATE_FMC = T
      JUST_INTERPOLATED = .TRUE.
      IF (WX_BILINEAR_INTERPOLATION) THEN
         CALL INTERP_RASTER_LINKEDLIST_BILINEAR(LIST_TAGGED, FMC_LO (:,:), FMC_HI (:,:), F_METEOROLOGY, 6)
      ELSE
         CALL INTERP_RASTER_LINKEDLIST(LIST_TAGGED, FMC_LO (:,:), FMC_HI (:,:), F_METEOROLOGY, 6)
      ENDIF
   ENDIF

   IF (T - T_LAST_INTERPOLATE_WIND .GE. DT_INTERPOLATE_WIND) THEN
      T_LAST_INTERPOLATE_WIND = T
      JUST_INTERPOLATED = .TRUE.
      IF (WX_BILINEAR_INTERPOLATION) THEN
!         CALL INTERP_RASTER_LINKEDLIST_BILINEAR(LIST_TAGGED, WS20_LO(:,:), WS20_HI(:,:), F_METEOROLOGY, 7)
         CALL INTERP_WIND_LINKEDLIST_BILINEAR(LIST_TAGGED, WS20_LO(:,:), WS20_HI(:,:), WD20_LO(:,:), WD20_HI(:,:), F_METEOROLOGY)
      ELSE
         CALL INTERP_RASTER_LINKEDLIST(LIST_TAGGED, WS20_LO(:,:), WS20_HI(:,:), F_METEOROLOGY, 7)
         CALL INTERP_WD_RASTER(LIST_TAGGED, WD20_LO(:,:), WD20_HI(:,:), F_METEOROLOGY)
      ENDIF
!      CALL INTERP_WD_RASTER(LIST_TAGGED, WD20_LO(:,:), WD20_HI(:,:), F_METEOROLOGY)
   ENDIF

   IF (WIND_FLUCTUATIONS .AND. T - T_LAST_WIND_FLUCTUATIONS .GE. DT_WIND_FLUCTUATIONS) THEN
      T_LAST_WIND_FLUCTUATIONS = T
      JUST_INTERPOLATED = .TRUE.
      CALL APPLY_WIND_FLUCTUATIONS(LIST_TAGGED)
   ENDIF

   CALL ACCUMULATE_CPU_USAGE(38, IT1, IT2)
   
! Main call to get spread rate:
   IF (JUST_INTERPOLATED) CALL SURFACE_SPREAD_RATE(LIST_TAGGED,DUMMY_NODE)
   CALL ACCUMULATE_CPU_USAGE(39, IT1, IT2)

! Adjust spread rate for passive and active crown fire (Cruz):
! Note that this adjusts spread rate in not only burned cells but nearby cells
! that are "about to burn"
   IF (CROWN_FIRE_MODEL .GT. 0 .AND. JUST_INTERPOLATED) CALL CROWN_SPREAD_RATE(LIST_TAGGED,DUMMY_NODE)
   CALL ACCUMULATE_CPU_USAGE(40, IT1, IT2)
   
   DO ISTEP = 1, 2

! Calcaulate components of normal vector
      CALL CALC_NORMAL_VECTORS (ISTEP, HALFRCELLSIZE)
      CALL ACCUMULATE_CPU_USAGE(41, IT1, IT2)

! Calculate x and y components of velocity from elliptical spread dimensions
      CALL UX_AND_UY_ELLIPTICAL(LIST_TAGGED, LIST_BURNED, SURFACE_ACCELERATION_FACTOR, ISTEP, T, DYNAMIC_ARRAY)
      CALL ACCUMULATE_CPU_USAGE(42, IT1, IT2)

! Check CFL criterion and adjust timestep
      IF (ISTEP .EQ. 1 .AND. ITIMESTEP .GT. 5) THEN
         CALL CALC_CFL(DT)
         CALL ACCUMULATE_CPU_USAGE(43, IT1, IT2)
      ENDIF

! Apply flux limiter
      CALL LIMIT_GRADIENTS(RCELLSIZE, PHIP)
      CALL ACCUMULATE_CPU_USAGE(44, IT1, IT2)

! 2nd order Runge Kutta integration:
      CALL RK2_INTEGRATE(DT, ISTEP)
      CALL ACCUMULATE_CPU_USAGE(45, IT1, IT2)

   ENDDO !ISTEP=1,2

! Find newly-burned cells and call spotting:
   N_TO_TAG = 0
   N_SPOT_FIRES = 0
   
   C => LIST_TAGGED%HEAD
   DO I = 1, LIST_TAGGED%NUM_NODES
      IX = C%IX
      IY = C%IY

      IF (PHIP(IX,IY) .LE. 0. .AND. SURFACE_FIRE(IX,IY) .EQ. 0) THEN
      
         ACRES = ACRES + ACRES_PER_PIXEL
         IF (USE_SDI) THEN
            ACRES_SDI = ACRES_SDI + ACRES_PER_PIXEL * (1.0 + C%SDI )
         ELSE
            ACRES_SDI = ACRES
         ENDIF

         C%BURNED               = .TRUE.
         C%TIME_OF_ARRIVAL      = T
         SURFACE_FIRE   (IX,IY) = 1
         TIME_OF_ARRIVAL(IX,IY) = T
         IF (C%CROWN_FIRE .LT. 0) C%CROWN_FIRE = 0
         
! Note that per Thomas (1963) and Rothermel (1991), crown fire flame length is Lf=0.2*I^2/3
         IF (C%FLIN_SURFACE .GT. 0.) THEN
            C%FLAME_LENGTH = (0.0775 / 0.3048) * (C%FLIN_SURFACE + C%FLIN_CANOPY) ** 0.46 
         ELSE
            C%FLAME_LENGTH = 0.
         ENDIF

         CALL APPEND(LIST_BURNED, IX, IY, T)
         CALL APPEND_TO_DYNAMIC_ARRAY(IX, IY, LIST_BURNED%NUM_NODES, DYNAMIC_ARRAY)

         LIST_BURNED%TAIL%IR                     = C%IR
         LIST_BURNED%TAIL%VS0                    = C%VS0
         LIST_BURNED%TAIL%PHIW_SURFACE           = C%PHIW_SURFACE
         LIST_BURNED%TAIL%PHIW_CROWN             = C%PHIW_CROWN
         LIST_BURNED%TAIL%PHIS_SURFACE           = C%PHIS_SURFACE
         LIST_BURNED%TAIL%VELOCITY_DMS           = C%VELOCITY_DMS
         LIST_BURNED%TAIL%VELOCITY               = C%VELOCITY
         LIST_BURNED%TAIL%FLIN_SURFACE           = C%FLIN_SURFACE
         LIST_BURNED%TAIL%FLIN_CANOPY            = C%FLIN_CANOPY
         LIST_BURNED%TAIL%FLAME_LENGTH           = C%FLAME_LENGTH
         LIST_BURNED%TAIL%HPUA_SURFACE           = C%HPUA_SURFACE
         LIST_BURNED%TAIL%HPUA_CANOPY            = C%HPUA_CANOPY
         LIST_BURNED%TAIL%UX                     = C%UX
         LIST_BURNED%TAIL%UY                     = C%UY
         LIST_BURNED%TAIL%TIME_OF_ARRIVAL        = C%TIME_OF_ARRIVAL
         LIST_BURNED%TAIL%CRITICAL_FLIN          = C%CRITICAL_FLIN
         LIST_BURNED%TAIL%CROWN_FIRE             = C%CROWN_FIRE
         LIST_BURNED%TAIL%BURNED                 = .TRUE.
         LIST_BURNED%TAIL%TAU_EMBERGEN           = 0.
         
         LIST_BURNED%TAIL%IFBFM                  = C%IFBFM
         LIST_BURNED%TAIL%IBLDGFM                = C%IBLDGFM 
         LIST_BURNED%TAIL%WS20_NOW               = C%WS20_NOW
         LIST_BURNED%TAIL%WD20_NOW               = C%WD20_NOW

         IF (ENABLE_SMOKE_OUTPUTS) THEN
            LIST_BURNED%TAIL%TIME_IGNITED = T
            IF (C%VELOCITY .GT. 0.) THEN
               TBURN = ASP%CELLSIZE / (C%VELOCITY * 0.3048 / 60.)
            ELSE
               TBURN = 30.0
            ENDIF
            TBURN = MIN(MAX(TBURN,1.),10800.0)
            LIST_BURNED%TAIL%TIME_EXTINGUISHED = T + TBURN
            LIST_BURNED%TAIL%HRRPUA = (C%FLIN_SURFACE + C%FLIN_CANOPY) / ASP%CELLSIZE
         ENDIF

         BINARY_OUTPUTS_IX           (LIST_BURNED%NUM_NODES) = IX
         BINARY_OUTPUTS_IY           (LIST_BURNED%NUM_NODES) = IY
         BINARY_OUTPUTS_TOA          (LIST_BURNED%NUM_NODES) = T
         BINARY_OUTPUTS_FLAME_LENGTH (LIST_BURNED%NUM_NODES) = C%FLAME_LENGTH
         BINARY_OUTPUTS_VELOCITY_FPM (LIST_BURNED%NUM_NODES) = C%VELOCITY
         BINARY_OUTPUTS_CROWN_FIRE   (LIST_BURNED%NUM_NODES) = C%CROWN_FIRE

         N_TO_TAG = N_TO_TAG + 1
         IX_TO_TAG(N_TO_TAG) = IX
         IY_TO_TAG(N_TO_TAG) = IY

         IF (ENABLE_SPOTTING) THEN
            CALL_SPOTTING = .FALSE.
            IF (.NOT. USE_UMD_SPOTTING_MODEL) THEN
               IF (C%FLIN_SURFACE .GE. C%CRITICAL_FLIN) THEN
                  CALL RANDOM_NUMBER(R0)
                  IF (R0 .LT. 0.01*CROWN_FIRE_SPOTTING_PERCENT) CALL_SPOTTING = .TRUE.
               ENDIF

               IF (ENABLE_SURFACE_FIRE_SPOTTING .AND. (.NOT. CALL_SPOTTING) ) THEN
                  IF (C%FLIN_SURFACE .GE. CRITICAL_SPOTTING_FIRELINE_INTENSITY(FBFM%I2(C%IX,C%IY,1))) THEN
                     CALL RANDOM_NUMBER(R0)
                     IF (R0 .LT. 0.01*SURFACE_FIRE_SPOTTING_PERCENT(FBFM%I2(C%IX,C%IY,1))) CALL_SPOTTING = .TRUE.
                     CONTINUE
                  ENDIF
               ENDIF
            ENDIF

            IF (CALL_SPOTTING) THEN
               ILH = MAX(MIN(NINT(100.*C%MLH),120),30)
               FMT = FUEL_MODEL_TABLE_2D(C%IFBFM,ILH)
               WN_FUEL = FMT%WN_DEAD+FMT%WN_LIVE
               IF (USE_SUPERSEDED_SPOTTING) THEN
                  CALL SPOTTING_SUPERSEDED ( IX,IY,C%WS20_NOW,C%FLIN_SURFACE,F_METEOROLOGY,WS20_LO,WS20_HI, WD20_LO, WD20_HI, &
                                  N_SPOT_FIRES,IX_SPOT_FIRE,IY_SPOT_FIRE,ICASE,DT, T,0., &
                                  SOURCE_FUEL_IGN_MULT (FBFM%I2(C%IX,C%IY,1)) )
               ELSE
                  CALL SPOTTING ( IX,IY,C%WS20_NOW,C%FLIN_SURFACE, N_SPOT_FIRES,IX_SPOT_FIRE,IY_SPOT_FIRE,&
                                  ICASE, DT, T, 0., SOURCE_FUEL_IGN_MULT (FBFM%I2(C%IX,C%IY,1)), &
                                  BLDG_FOOTPRINT_FRAC%R4(C%IX,C%IY,1), C%FMC, C%IFBFM, WN_FUEL) ! Parameters added to calculate number of physical embers
               ENDIF
            ENDIF
         ENDIF ! ENABLE_SPOTTING

      ENDIF

      C => C%NEXT

   ENDDO ! I = 1, LIST_TAGGED%NUM_NODES

   IF (ENABLE_SPOTTING .AND. USE_UMD_SPOTTING_MODEL) THEN
      C => LIST_BURNED%HEAD
      DO I = 1, LIST_BURNED%NUM_NODES
         CALL_SPOTTING = .FALSE.
         IF (USE_PHYSICAL_SPOTTING_DURATION) THEN
            IF (C%T_START_SPOTTING .LT. 0.0) THEN
               IF (C%IFBFM .EQ. 91 ) THEN
                  IF(USE_BLDG_SPREAD_MODEL .AND. (BLDG_SPREAD_MODEL_TYPE .EQ. 2)) THEN
                     IF (C%HRR_TRANSIENT .GE. CRITICAL_SPOTTING_FIRELINE_INTENSITY(FBFM%I2(C%IX,C%IY,1))/ANALYSIS_CELLSIZE ) THEN
                        C%T_START_SPOTTING = T
                        T_TOTAL = BUILDING_FUEL_MODEL_TABLE(C%IBLDGFM)%T_DECAY+ &
                                 2*0.3*C%HRR_TRANSIENT*(1.0-BUILDING_FUEL_MODEL_TABLE(C%IBLDGFM)%NONBURNABLE_FRAC) * &
                                 ANALYSIS_CELLSIZE*ANALYSIS_CELLSIZE/MAX(BUILDING_FUEL_MODEL_TABLE(C%IBLDGFM)%T_DECAY,1E-5)

                        C%T_END_SPOTTING = T_TOTAL-CRITICAL_SPOTTING_FIRELINE_INTENSITY(FBFM%I2(C%IX,C%IY,1))/ &
                                          MAX(BUILDING_FUEL_MODEL_TABLE(C%IBLDGFM)%HRRPUA_PEAK, 1E-5) * & 
                                          (T_TOTAL-BUILDING_FUEL_MODEL_TABLE(C%IBLDGFM)%T_DECAY);
                        C%T_END_SPOTTING = MAX(C%T_END_SPOTTING,BUILDING_FUEL_MODEL_TABLE(C%IBLDGFM)%T_DECAY)
                        C%T_END_SPOTTING = MIN(C%T_END_SPOTTING,T_TOTAL)
                        C%T_END_SPOTTING = C%T_START_SPOTTING + C%T_END_SPOTTING
                     ENDIF
                  ELSE
                     C%T_START_SPOTTING = C%TIME_OF_ARRIVAL
                     C%T_END_SPOTTING = C%T_START_SPOTTING+TAU_EMBERGEN
                  ENDIF ! IF(USE_BLDG_SPREAD_MODEL)
               ELSE
                  C%T_START_SPOTTING = C%TIME_OF_ARRIVAL
                  C%T_END_SPOTTING = C%T_START_SPOTTING+C%LOCAL_EMBERGEN_DURATION
               ENDIF ! IF (C%T_START_SPOTTING .LT. 1E-3) THEN
            ENDIF ! IF (USE_PHYSICAL_SPOTTING_DURATION) THEN
         ELSE
            IF (C%T_START_SPOTTING .LT. 0.0) THEN
               C%T_START_SPOTTING = C%TIME_OF_ARRIVAL
               C%T_END_SPOTTING = C%T_START_SPOTTING+TAU_EMBERGEN
            ENDIF
         ENDIF
         IF (T .GE. C%T_START_SPOTTING .AND. T .LE. C%T_END_SPOTTING) THEN
            IF (C%FLIN_SURFACE .GE. CRITICAL_SPOTTING_FIRELINE_INTENSITY(FBFM%I2(C%IX,C%IY,1))) THEN
               CALL RANDOM_NUMBER(R0)
               IF (R0 .LT. 0.01*SURFACE_FIRE_SPOTTING_PERCENT(FBFM%I2(C%IX,C%IY,1))) CALL_SPOTTING = .TRUE. 
               CONTINUE
            ENDIF
            IF (CALL_SPOTTING) THEN
               ILH = MAX(MIN(NINT(100.*C%MLH),120),30)
               FMT = FUEL_MODEL_TABLE_2D(C%IFBFM,ILH)
               WN_FUEL = FMT%WN_DEAD+FMT%WN_LIVE
               IF (USE_SUPERSEDED_SPOTTING) THEN
                  CALL SPOTTING_SUPERSEDED ( IX,IY,C%WS20_NOW,C%FLIN_SURFACE,F_METEOROLOGY,WS20_LO,WS20_HI, WD20_LO, WD20_HI, &
                                  N_SPOT_FIRES,IX_SPOT_FIRE,IY_SPOT_FIRE,ICASE,DT, T,0., &
                                  SOURCE_FUEL_IGN_MULT (FBFM%I2(C%IX,C%IY,1)) )
               ELSE
                  CALL SPOTTING ( C%IX,C%IY,C%WS20_NOW,C%FLIN_SURFACE,N_SPOT_FIRES,IX_SPOT_FIRE,IY_SPOT_FIRE,&
                                  ICASE,DT,T, C%TAU_EMBERGEN,SOURCE_FUEL_IGN_MULT (FBFM%I2(C%IX,C%IY,1)),&
                                  BLDG_FOOTPRINT_FRAC%R4(C%IX,C%IY,1), C%FMC, C%IFBFM, WN_FUEL) ! Parameters added to calculate number of physical embers
               ENDIF
            ENDIF
         ENDIF
         C%TAU_EMBERGEN = MIN (TAU_EMBERGEN, C%TAU_EMBERGEN + DT)
         C => C%NEXT
      ENDDO
   ENDIF

   CALL ACCUMULATE_CPU_USAGE(46, IT1, IT2)

   DO I = 1, N_TO_TAG
      CALL TAG_BAND(NX, NY, IX_TO_TAG(I), IY_TO_TAG(I), T)
   ENDDO

   IF (USE_UMD_SPOTTING_MODEL) THEN
      IF (USE_EULERIAN_SPOTTING) THEN
         DO IY = 1,NY
            DO IX = 1,NX
               IF(PHIP(IX,IY) .GE. 0 .AND. SURFACE_FIRE(IX,IY) .LE. 0) THEN
               IF (USE_EMBER_IGNITION_MODEL) THEN
                  ICOL = ICOL_ANALYSIS_F2C(IX)
                  IROW = IROW_ANALYSIS_F2C(IY)
                  WS20 = WS20_LO(ICOL,IROW) * (1. - F_METEOROLOGY) + F_METEOROLOGY * WS20_HI(ICOL,IROW)
                  ! Lines added to utilize the tabulated ignition probability proposed by UCB
                  IFBFM = FBFM%I2(IX,IY,1)
                  IF(IFBFM .NE. 91) THEN
                     P_IGNITION = PIGN
                     HARDENING_FACTOR_LOCAL = 1.0
                  ELSE
                     IF(USE_BLDG_SPREAD_MODEL .AND. BLDG_SPREAD_MODEL_TYPE .EQ. 2) THEN
                        IBLDGFM = BLDG_FUEL_MODEL%I2(IX,IY,1)
                        P_IGNITION = BUILDING_FUEL_MODEL_TABLE(IBLDGFM)%P_IGNITION
                        HARDENING_FACTOR_LOCAL = BUILDING_FUEL_MODEL_TABLE(IBLDGFM)%HARDENING_FACTOR
                     ELSE
                        P_IGNITION = PIGN
                        HARDENING_FACTOR_LOCAL = GLOBAL_HARDENING_FACTOR
                     ENDIF
                  ENDIF

                  IF (.NOT. EMBER_IGNITION(IX,IY,T, DT, WS20, P_IGNITION, LOCAL_IGNITION_TIME, CELL_IGNITION_DELAY, HARDENING_FACTOR_LOCAL)) CYCLE
               ELSE
                  IF (ABS(EMBER_TIGN(IX,IY) - T-DT) .GE. 0.5*DT .OR. EMBER_TIGN(IX,IY) .LT. 0) CYCLE
               ENDIF
               IF (ADJ%R4(IX,IY,1) .GT. 0. .AND. (.NOT. ISNONBURNABLE(IX,IY) ) ) THEN
                  CALL TAG_BAND(NX, NY, IX, IY, T+DT)
                  PHIP           (IX,IY) = -1.0
                  ! Record firebrand ignited cells
                  IF (DEBUG_LEVEL .GT. 0) WRITE(*,*) 'Firebrand Ignited', IX, IY, IFBFM
               ENDIF
               ENDIF
            ENDDO
         ENDDO
      ELSE
         DO I = 1, NUM_TRACKED_EMBERS
            IF (.NOT. SPOTTING_STATS(I)%POSITIVE_IGNITION ) CYCLE
            IF (SPOTTING_STATS(I)%ALREADY_IGNITED         ) CYCLE
            IF (SPOTTING_STATS(I)%TIGN .GT. T+DT          ) CYCLE ! the criterion should be T+DT instead of T

            SPOTTING_STATS(I)%ALREADY_IGNITED = .TRUE.

            IX = SPOTTING_STATS(I)%IX_TO
            IY = SPOTTING_STATS(I)%IY_TO

            IF (SURFACE_FIRE(IX,IY) .LE. 0 .AND. ADJ%R4(IX,IY,1) .GT. 0. .AND. (.NOT. ISNONBURNABLE(IX,IY) ) ) THEN
               CALL TAG_BAND(NX, NY, IX, IY, T)
               TIME_OF_ARRIVAL(IX,IY) = T
               PHIP           (IX,IY) = -1.0

               IF (DUMP_SPOTTING_OUTPUTS) THEN
                  FN = TRIM(OUTPUTS_DIRECTORY) // 'spotting_stats_' // SEVEN_ICASE // '.csv'
                  INQUIRE(UNIT=712,OPENED=LOPEN)
                  IF (.NOT. LOPEN) THEN
                     OPEN(712,FILE=TRIM(FN),FORM='FORMATTED',STATUS='REPLACE',IOSTAT=IOS)
                     WRITE(712,'(A)') 'IX_FROM, IY_FROM, IX_TO, IY_TO, TLAUNCH, TIGN'
                  ENDIF

                  WRITE(712,998) SPOTTING_STATS(I)%IX_FROM, SPOTTING_STATS(I)%IY_FROM, IX, IY, SPOTTING_STATS(I)%TLAUNCH, SPOTTING_STATS(I)%TIGN
               ENDIF

            ENDIF
         ENDDO
         CALL CLEAR_USED_EMBER(T)
      ENDIF
   ELSE
      DO I = 1, N_SPOT_FIRES
         IX = IX_SPOT_FIRE(I)
         IY = IY_SPOT_FIRE(I)
         IF (SURFACE_FIRE(IX,IY) .LE. 0 .AND. ADJ%R4(IX,IY,1) .GT. 0. .AND. (.NOT. ISNONBURNABLE(IX,IY) ) ) THEN
            CALL TAG_BAND(NX, NY, IX, IY, T)
            TIME_OF_ARRIVAL(IX,IY) = T
            PHIP           (IX,IY) = -1.0
            IF (DEBUG_LEVEL .GT. 0) WRITE(*,*) 'Firebrand Ignited', IX, IY, IFBFM
         ENDIF
      ENDDO
   ENDIF

   CALL ACCUMULATE_CPU_USAGE(47, IT1, IT2)

! Map wind & fuel moisture fields to newly tagged cells:
   C => LIST_TAGGED%HEAD
   DO I = 1, LIST_TAGGED%NUM_NODES
      IF (C%JUST_TAGGED) THEN
         C%JUST_TAGGED = .FALSE.
         IF (WX_BILINEAR_INTERPOLATION) THEN
            CALL INTERP_RASTER_LINKEDLIST_SINGLE_BILINEAR (C, M1_LO  (:,:), M1_HI  (:,:), F_METEOROLOGY, 1)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE_BILINEAR (C, M10_LO (:,:), M10_HI (:,:), F_METEOROLOGY, 2)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE_BILINEAR (C, M100_LO(:,:), M100_HI(:,:), F_METEOROLOGY, 3)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE_BILINEAR (C, MLH_LO (:,:), MLH_HI (:,:), F_METEOROLOGY, 4)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE_BILINEAR (C, MLW_LO (:,:), MLW_HI (:,:), F_METEOROLOGY, 5)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE_BILINEAR (C, FMC_LO (:,:), FMC_HI (:,:), F_METEOROLOGY, 6)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE_BILINEAR (C, WS20_LO(:,:), WS20_HI(:,:), F_METEOROLOGY, 7)
         ELSE
            CALL INTERP_RASTER_LINKEDLIST_SINGLE (C, M1_LO  (:,:), M1_HI  (:,:), F_METEOROLOGY, 1)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE (C, M10_LO (:,:), M10_HI (:,:), F_METEOROLOGY, 2)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE (C, M100_LO(:,:), M100_HI(:,:), F_METEOROLOGY, 3)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE (C, MLH_LO (:,:), MLH_HI (:,:), F_METEOROLOGY, 4)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE (C, MLW_LO (:,:), MLW_HI (:,:), F_METEOROLOGY, 5)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE (C, FMC_LO (:,:), FMC_HI (:,:), F_METEOROLOGY, 6)
            CALL INTERP_RASTER_LINKEDLIST_SINGLE (C, WS20_LO(:,:), WS20_HI(:,:), F_METEOROLOGY, 7)
         ENDIF
         
         CALL INTERP_WD_RASTER_SINGLE(C, WD20_LO(:,:), WD20_HI(:,:), F_METEOROLOGY)
         CALL SURFACE_SPREAD_RATE(LIST_TAGGED,C)
         IF (CROWN_FIRE_MODEL .GT. 0) CALL CROWN_SPREAD_RATE(LIST_TAGGED,C)
         IF (USE_SDI) C%SDI = SDI_FACTOR * SDI%R4(C%IX,C%IY,1)
      ENDIF
      C => C%NEXT
   ENDDO
      
   CALL ACCUMULATE_CPU_USAGE(48, IT1, IT2)

! Initial attack model:
   IF (ENABLE_INITIAL_ATTACK .AND. T .GE. INITIAL_ATTACK_TIME .AND. (.NOT. IA_HAS_OCCURRED) ) THEN
      IA_HAS_OCCURRED = .TRUE.
      HECTARES = 0.
      FLIN_MAX = 0.
      C => LIST_BURNED%HEAD
      DO I = 1, LIST_BURNED%NUM_NODES
         IX = C%IX
         IY = C%IY
         HECTARES = HECTARES + 1.
         IF (T - TIME_OF_ARRIVAL(IX,IY) .LE. MAX(300.,DT)) THEN
            IF ( (C%FLIN_SURFACE + C%FLIN_CANOPY) .GT. FLIN_MAX) FLIN_MAX = (C%FLIN_SURFACE + C%FLIN_CANOPY)
         ENDIF   
      C => C%NEXT
      ENDDO
      HECTARES = 0.404686 * ACRES_PER_PIXEL * HECTARES

      E = EXP(4.6835 - 0.7043 * HECTARES - 0.00041 * FLIN_MAX - 0.000052 * HECTARES * FLIN_MAX)
      POC = MIN(MAX(0.,E/(1.+E)),1.0)
      CALL RANDOM_NUMBER(R0)
      IF (R0 .LE. POC) THEN !Fire is contained
         T = TSTOP + 1.
         STATS_FINAL_CONTAINMENT_FRAC(ICASE) = 1.0
         STATS_SIMULATION_TSTOP_HOURS(ICASE) = INITIAL_ATTACK_TIME / 3600.0
      ENDIF
   ENDIF
   
   CALL ACCUMULATE_CPU_USAGE(49, IT1, IT2)
   
   CALL ACCUMULATE_CPU_USAGE(50, IT1, IT2)

! Untag
   IF (MOD(ITIMESTEP,UNTAG_CELLS_TIMESTEP_INTERVAL) .EQ. 0 .AND. LIST_TAGGED%NUM_NODES .GT. 100) THEN 
      CALL UNTAG_CELLS(NX,NY,TIME_OF_ARRIVAL,T,SURFACE_FIRE)
   ENDIF

   CALL ACCUMULATE_CPU_USAGE(51, IT1, IT2)

   IF (LIST_TAGGED%NUM_NODES .LE. 2) THEN
      SIMULATION_TSTOP_HOURS = T / 3600.
      STATS_SIMULATION_TSTOP_HOURS(ICASE) = SIMULATION_TSTOP_HOURS
      STATS_FINAL_CONTAINMENT_FRAC(ICASE) = 1.0
      T = TSTOP + 1.
      IDUMPCOUNT = NDUMPS + 1
   ENDIF

   IF (ACRES .GT. STATS_ASTOP(ICASE) ) THEN
      SIMULATION_TSTOP_HOURS = T / 3600.
      STATS_SIMULATION_TSTOP_HOURS(ICASE) = SIMULATION_TSTOP_HOURS
      T = TSTOP + 1.
      IDUMPCOUNT = NDUMPS + 1
   ENDIF
   
   IF (NUM_TIME_AT_BURNED_ACRES .GT. 0) THEN
      FN = TRIM(OUTPUTS_DIRECTORY) // 'burned-acres-timings_' // FOUR_IRANK_WORLD // '.csv'
      INQUIRE(UNIT=LUBAT+IRANK_WORLD,OPENED=LOPEN)
      IF (.NOT. LOPEN) OPEN(LUBAT+IRANK_WORLD,FILE=TRIM(FN),FORM='FORMATTED',STATUS='REPLACE',IOSTAT=IOS)
      DO I = 1, NUM_TIME_AT_BURNED_ACRES
          IF (ALREADY_REACHED_BURNED_ACRES(I)) CYCLE
          IF (ACRES .LT. TIME_AT_BURNED_ACRES(I)) CYCLE
          ALREADY_REACHED_BURNED_ACRES(I) = .TRUE.
          CALL SYSTEM_CLOCK(IT2_LSP)
          RUNTIME = (IT2_LSP - IT1_LSP) / REAL(CLOCK_COUNT_RATE)

          IF (T .GT. TSTOP .AND. STATS_SIMULATION_TSTOP_HOURS(ICASE) .GT. 0) THEN
             WRITE(LUBAT+IRANK_WORLD, 777) ICASE, TIME_AT_BURNED_ACRES(I), STATS_SIMULATION_TSTOP_HOURS(ICASE), RUNTIME
          ELSE
             WRITE(LUBAT+IRANK_WORLD, 777) ICASE, TIME_AT_BURNED_ACRES(I), T/3600.0, RUNTIME
          ENDIF
      ENDDO
   ENDIF
777 FORMAT (I7, ',', F8.1, ',', F7.2, ',', F8.3)
   
! Extended attack model
   IF (ITIMESTEP .EQ. 1) T_LAST_EXTENDED_ATTACK = T
   IF (ENABLE_EXTENDED_ATTACK .AND. T - T_LAST_EXTENDED_ATTACK .GT. DT_EXTENDED_ATTACK .AND. LIST_BURNED%NUM_NODES .GT. 0) THEN
      IT_EA = IT_EA + 1
      DT_DAY = (T - T_LAST_EXTENDED_ATTACK) / 86400.
      SUPP(IT_EA)%T         = T
      SUPP(IT_EA)%ACRES     = ACRES
      SUPP(IT_EA)%ACRES_SDI = ACRES_SDI

      SUPP(IT_EA)%DADT    = (ACRES     - SUPP(IT_EA-1)%ACRES    ) / DT_DAY
      SUPP(IT_EA)%DASDIDT = (ACRES_SDI - SUPP(IT_EA-1)%ACRES_SDI) / DT_DAY
      IF (SUPP(IT_EA)%DADT .GT. 0.) THEN
         SUPP(IT_EA)%SDIBAR = MIN(MAX(SUPP(IT_EA)%DASDIDT / SUPP(IT_EA)%DADT - 1.0, 0.0), 3.0)
      ELSE
          SUPP(IT_EA)%SDIBAR = 0
      ENDIF
      IF ( ABS(SUPP(IT_EA)%DADT) .LT. 1E-6 ) THEN
         SUPP(IT_EA)%DC_PER_DAY = 0.
      ELSE
         IF (USE_SDI_LOG_FUNCTION) THEN
            SUPP(IT_EA)%DC_PER_DAY = 0.01 * DIURNAL_ADJUSTMENT_FACTOR * MAX_CONTAINMENT_PER_DAY * (1. - LOG10(SUPP(IT_EA)%DADT) / LOG10(AREA_NO_CONTAINMENT_CHANGE) )
         ELSE
            SUPP(IT_EA)%DC_PER_DAY = 0.01 * DIURNAL_ADJUSTMENT_FACTOR * MAX_CONTAINMENT_PER_DAY * (1. - SUPP(IT_EA)%DADT        / AREA_NO_CONTAINMENT_CHANGE       )
         ENDIF
      ENDIF
      IF (SUPP(IT_EA)%DC_PER_DAY .GT. 0.) THEN
         SUPP(IT_EA)%DC_PER_DAY = SUPP(IT_EA)%DC_PER_DAY * EXP(-B_SDI * SUPP(IT_EA)%SDIBAR)
      ELSE
         SUPP(IT_EA)%DC_PER_DAY = SUPP(IT_EA)%DC_PER_DAY * EXP( B_SDI * SUPP(IT_EA)%SDIBAR)
      ENDIF
      
      SUPP(IT_EA)%TARGET_CONTAINMENT = SUPP(IT_EA-1)%TARGET_CONTAINMENT  + SUPP(IT_EA)%DC_PER_DAY * DT_DAY
      IF (SUPP(IT_EA)%TARGET_CONTAINMENT .GT. 1. ) SUPP(IT_EA)%TARGET_CONTAINMENT = 1.
      IF (SUPP(IT_EA)%TARGET_CONTAINMENT .LT. 0. ) SUPP(IT_EA)%TARGET_CONTAINMENT = 0.
      
      CALL CENTROID(IT_EA)
      CALL CONTAINMENT(IT_EA,T)
      CALL UNTAG_CELLS(NX,NY,TIME_OF_ARRIVAL,T,SURFACE_FIRE)
      T_LAST_EXTENDED_ATTACK = T

      CONTINUE
   ENDIF

   CALL ACCUMULATE_CPU_USAGE(52, IT1, IT2)

   IF (ENABLE_SMOKE_OUTPUTS .AND. T - T_LAST_SMOKE_OUTPUT .GE. DT_SMOKE_OUTPUTS ) THEN
      QDOTNOW = 0.
      MDOTNOW = 0.
      XCEN    = 0.
      YCEN    = 0.

      C => LIST_BURNED%HEAD
      DO I = 1, LIST_BURNED%NUM_NODES
         IF (C%TIME_EXTINGUISHED .GE. T_LAST_SMOKE_OUTPUT) THEN
            THI = MIN(T,C%TIME_EXTINGUISHED)
            TLO = MAX(T_LAST_SMOKE_OUTPUT,C%TIME_IGNITED)
            C%SMOKE_TFRAC = (THI - TLO) / (T - T_LAST_SMOKE_OUTPUT)
            C%QDOT_AVG = C%HRRPUA * ASP%CELLSIZE * ASP%CELLSIZE * C%SMOKE_TFRAC !kW
            XCEN = XCEN + C%QDOT_AVG * REAL(C%IX)
            YCEN = YCEN + C%QDOT_AVG * REAL(C%IY)
            QDOTNOW = QDOTNOW + C%QDOT_AVG ! kW
            MDOTNOW = MDOTNOW + SMOKE_YIELD_BY_FUEL(C%IFBFM) * C%QDOT_AVG / (1000. * SMOKE_HOC) !kg/s
         ENDIF
         C => C%NEXT
      ENDDO

      IF (QDOTNOW .GT. 0.) THEN
         IXCEN = NINT(XCEN/QDOTNOW)
         IYCEN = NINT(YCEN/QDOTNOW)
      ELSE
         IXCEN = IX_IGN
         IYCEN = IY_IGN
         QDOTNOW = 0.
      ENDIF

      XCEN = X_FROM_ICOL (IXCEN, ADJ%XLLCORNER, ADJ%CELLSIZE)
      YCEN = Y_FROM_IROW (IYCEN, ADJ%YLLCORNER, ADJ%CELLSIZE)

! Determine effective radius
      RADIUS = 0.
      C => LIST_BURNED%HEAD
      DO I = 1, LIST_BURNED%NUM_NODES
         IF (C%TIME_EXTINGUISHED .GE. T_LAST_SMOKE_OUTPUT) THEN
            RADIUS = RADIUS + C%QDOT_AVG * SQRT( (REAL(C%IX) - REAL(IXCEN))**2 + (REAL(C%IY) - REAL(IYCEN))**2 )
         ENDIF
         C => C%NEXT
      ENDDO

      IF (QDOTNOW .GT. 0.) THEN
         RADIUS = RADIUS * ADJ%CELLSIZE / QDOTNOW
      ELSE
         RADIUS = 0.
      ENDIF

      IF (0.001*QDOTNOW .GT. STATS_HRR_PEAK(ICASE)) STATS_HRR_PEAK(ICASE) = 0.001*QDOTNOW ! MW
      STATS_PM2P5_RELEASE(ICASE) = STATS_PM2P5_RELEASE(ICASE) + 3.6E12 * MDOTNOW * (T - T_LAST_SMOKE_OUTPUT) / 3600. !ug

      T_LAST_SMOKE_OUTPUT = REAL (NINT ( T / DT_SMOKE_OUTPUTS)) * DT_SMOKE_OUTPUTS

      IF (DUMP_SMOKE_OUTPUTS) THEN
         FN = TRIM(OUTPUTS_DIRECTORY) // 'smoke_' // SEVEN_ICASE // '.csv'
         INQUIRE(UNIT=LUSMOKE+IRANK_WORLD,OPENED=LOPEN)
         IF (.NOT. LOPEN) THEN
            OPEN(LUSMOKE+IRANK_WORLD,FILE=TRIM(FN),FORM='FORMATTED',STATUS='REPLACE',IOSTAT=IOS)
            WRITE(LUSMOKE+IRANK_WORLD,'(A)') 't (h),timestamp,xcen (m),ycen (m),area (ha),HRR (MW),mdotsmoke (ug/h)'
         ENDIF
         HOUR_OF_YEAR = NINT( REAL(BAND_ONE_HOUR_OF_YEAR + IWX_BAND) + T_LAST_SMOKE_OUTPUT/3600. - 1.)
         TIMESTAMP = HOUR_OF_YEAR_TO_TIMESTAMP (CURRENT_YEAR, HOUR_OF_YEAR)

         WRITE(LUSMOKE+IRANK_WORLD,999) T_LAST_SMOKE_OUTPUT/3600.0, TIMESTAMP, XCEN, YCEN, ACRES*0.404686, &
                                        0.001*QDOTNOW, 3.6E12*MDOTNOW
      ENDIF
      
   ENDIF ! ENABLE_SMOKE_OUTPUTS

998 FORMAT(I9.1,',',I9.1,',',I9.1,',',I9.1,',',F12.2,',',F12.2)
999 FORMAT(F9.2,',',A,',',F10.1,',',F10.1,',',E12.5,',',E12.5,',',E12.5)

   CALL ACCUMULATE_CPU_USAGE(53, IT1, IT2)

!Dump main GIS outputs:
   IF (ABS(T - DUMPTIMES(IDUMPCOUNT)) .LE. 0.5*DT .OR. T .GE. DUMPTIMES(IDUMPCOUNT) .OR. T .GE. TSTOP) THEN
      CALL MAIN_DUMP_ROUTINE(IDUMPCOUNT, NDUMPS, ICASE, T, ACRES)
   ENDIF

!   IF (T .GE. TSTOP) THEN
!      CALL LL_DUMP_ROUTINE(LIST_SUPPRESSED,'time_suppressed',T,'time_suppressed',ICASE) 
!      CALL LL_DUMP_ROUTINE(LIST_BURNED,'time_of_arrival',T,'time_of_arrival',ICASE) 
!   ENDIF

   CALL ACCUMULATE_CPU_USAGE(54, IT1, IT2)

   CALL SYSTEM_CLOCK(ITNOW)
   ELAPSED_TIME = REAL(ITNOW - ITSTART) / REAL(CLOCK_COUNT_RATE)

   IF (ELAPSED_TIME .GT. MAX_RUNTIME) THEN
      SIMULATION_TSTOP_HOURS = T / 3600.
      STATS_SIMULATION_TSTOP_HOURS(ICASE) = SIMULATION_TSTOP_HOURS
      T = TSTOP + 1.
      IDUMPCOUNT = NDUMPS + 1
   ENDIF

   CALL ACCUMULATE_CPU_USAGE(55, IT1, IT2)
ENDDO !T < TSTOP
! End main timestepping loop

CALL SYSTEM_CLOCK(IT1)

NTIMESTEPS = ITIMESTEP

INQUIRE(UNIT=712,OPENED=LOPEN)
IF (LOPEN) CLOSE(712)

CALL ACCUMULATE_CPU_USAGE(56, IT1, IT2)

IF (PROCESS_TIMED_LOCATIONS) THEN
   FN = TRIM(OUTPUTS_DIRECTORY) // 'timed-locations-events_' // FOUR_IRANK_WORLD // '.csv'
   INQUIRE(UNIT=LUTASL+IRANK_WORLD,OPENED=LOPEN)
   IF (.NOT. LOPEN) OPEN(LUTASL+IRANK_WORLD,FILE=TRIM(FN),FORM='FORMATTED',STATUS='REPLACE',IOSTAT=IOS)

   C => LIST_BURNED%HEAD
   DO I = 1, LIST_BURNED%NUM_NODES
      DO J = 1, NUM_TIMED_LOCATIONS
         IF (C%IX .NE. TIMED_LOCATIONS_TRACKER(J)%IX ) CYCLE
         IF (C%IY .NE. TIMED_LOCATIONS_TRACKER(J)%IY ) CYCLE
         WRITE(LUTASL+IRANK_WORLD,888) ICASE, TIMED_LOCATIONS_TRACKER(J)%ID, C%TIME_OF_ARRIVAL / 3600.
      ENDDO
      C => C%NEXT
   ENDDO
ENDIF
888 FORMAT (I7, ',', I8, ',', F7.2)

! Calculate fire area
IF (DUMP_FIRE_SIZE_STATS) THEN
   STATS_SURFACE_FIRE_AREA(ICASE) = 0.
   STATS_CROWN_FIRE_AREA  (ICASE) = 0.
   STATS_FIRE_VOLUME      (ICASE) = 0.

   C => LIST_BURNED%HEAD
   DO I = 1, LIST_BURNED%NUM_NODES
      IX = C%IX
      IY = C%IY
      STATS_SURFACE_FIRE_AREA(ICASE)   = STATS_SURFACE_FIRE_AREA(ICASE)   + 1.
      STATS_FIRE_VOLUME(ICASE) = STATS_FIRE_VOLUME(ICASE) + C%FLAME_LENGTH
      IF (C%CROWN_FIRE .GT. 0) STATS_CROWN_FIRE_AREA(ICASE) = STATS_CROWN_FIRE_AREA(ICASE) + 1.
      C => C%NEXT
   ENDDO
   
   STATS_SURFACE_FIRE_AREA(ICASE) = ACRES_PER_PIXEL * STATS_SURFACE_FIRE_AREA(ICASE)
   STATS_FIRE_VOLUME      (ICASE) = ACRES_PER_PIXEL * STATS_FIRE_VOLUME      (ICASE)
   STATS_CROWN_FIRE_AREA  (ICASE) = ACRES_PER_PIXEL * STATS_CROWN_FIRE_AREA  (ICASE)

   IF (USE_POPULATION_DENSITY) THEN
      STATS_AFFECTED_POPULATION(ICASE) = 0.0
      C => LIST_BURNED%HEAD
      DO I = 1, LIST_BURNED%NUM_NODES
         IX = C%IX
         IY = C%IY
         IF (POPULATION_DENSITY%R4(IX,IY,1) .LE. 0.) THEN
            C => C%NEXT
            CYCLE 
         ENDIF
         STATS_AFFECTED_POPULATION(ICASE) = STATS_AFFECTED_POPULATION(ICASE) + POPULATION_DENSITY%R4(IX,IY,1)
         C => C%NEXT
      ENDDO

      IF (ESTIMATE_URBAN_LOSSES) THEN
         C => LIST_BURNED%HEAD
         DO K = 1, LIST_BURNED%NUM_NODES
            IX = C%IX
            IY = C%IY
            DO J = MAX(1,IY-1), MIN(NY,IY+1)
            DO I = MAX(1,IX-1), MIN(NX,IX+1)
               IF ( (FBFM%I2(I,J,1) .EQ. 91) .AND. (POPULATION_DENSITY%R4(I,J,1) .GT. 0.) ) THEN
                  SURFACE_FIRE(I,J) = 1

                  CALL APPEND(LIST_BURNED, I, J, T)

                  STATS_SURFACE_FIRE_AREA(ICASE) = STATS_SURFACE_FIRE_AREA(ICASE) + ACRES_PER_PIXEL
                  STATS_AFFECTED_POPULATION(ICASE) = STATS_AFFECTED_POPULATION(ICASE) + POPULATION_DENSITY%R4(I,J,1)
               ENDIF
            ENDDO !I
            ENDDO !J
            C => C%NEXT
         ENDDO
      ENDIF !ESTIMATE_URBAN_LOSSES

! Population density is per acre
      STATS_AFFECTED_POPULATION(ICASE) = STATS_AFFECTED_POPULATION(ICASE)  * ACRES_PER_PIXEL
   ELSE
      STATS_AFFECTED_POPULATION(ICASE) = -1.0 
   ENDIF

   IF (USE_REAL_ESTATE_VALUE) THEN
      STATS_AFFECTED_REAL_ESTATE_VALUE(ICASE) = 0.0
      C => LIST_BURNED%HEAD
      DO I = 1, LIST_BURNED%NUM_NODES
         IX = C%IX
         IY = C%IY
         IF (REAL_ESTATE_VALUE%R4(IX,IY,1) .LE. 0.) THEN
             C => C%NEXT
             CYCLE 
         ENDIF
         STATS_AFFECTED_REAL_ESTATE_VALUE(ICASE) = STATS_AFFECTED_REAL_ESTATE_VALUE(ICASE) + REAL_ESTATE_VALUE%R4(IX,IY,1)
         C => C%NEXT
      ENDDO
      
! Since each cell as units of sq m, we have to convert:
      STATS_AFFECTED_REAL_ESTATE_VALUE(ICASE) = STATS_AFFECTED_REAL_ESTATE_VALUE(ICASE) * ACRES_PER_PIXEL
   ELSE
      STATS_AFFECTED_REAL_ESTATE_VALUE(ICASE) = -1.0 
   ENDIF

   IF (USE_LAND_VALUE) THEN
      STATS_AFFECTED_LAND_VALUE(ICASE) = 0.0
      C => LIST_BURNED%HEAD
      DO I = 1, LIST_BURNED%NUM_NODES
         IX = C%IX
         IY = C%IY
         IF (LAND_VALUE%R4(IX,IY,1) .LE. 0.) THEN
            C => C%NEXT
            CYCLE 
         ENDIF
         IF (C%CROWN_FIRE .GE. 1) STATS_AFFECTED_LAND_VALUE(ICASE) = STATS_AFFECTED_LAND_VALUE(ICASE) + LAND_VALUE%R4(IX,IY,1)
         C => C%NEXT
      ENDDO
! Since each cell as units of sq m, we have to convert:
      STATS_AFFECTED_LAND_VALUE(ICASE) = STATS_AFFECTED_LAND_VALUE(ICASE)  * ACRES_PER_PIXEL
   ELSE
      STATS_AFFECTED_LAND_VALUE(ICASE) = -1.0 
   ENDIF

ENDIF

CALL ACCUMULATE_CPU_USAGE(57, IT1, IT2)

IF (DUMP_BINARY_OUTPUTS .AND. ACRES .GT. MINIMUM_AREA_FOR_BINARY_OUTPUTS) THEN
   CALL RANDOM_NUMBER(R0)
   IF (R0 .LT. BINARY_OUTPUTS_DUMP_FRACTION) THEN
      LU=LUOUTPUT + IRANK_WORLD
      FN = TRIM(OUTPUTS_DIRECTORY) // 'toa_' // FOUR_IWX_BAND // '_' // SEVEN_ICASE // '.bin'
      OPEN(LU, FILE=TRIM(FN), FORM='UNFORMATTED', ACCESS='SEQUENTIAL', STATUS='REPLACE') 
      WRITE(LU) LIST_BURNED%NUM_NODES
      WRITE(LU) (BINARY_OUTPUTS_IX(I), I=1, LIST_BURNED%NUM_NODES)
      WRITE(LU) (BINARY_OUTPUTS_IY(I), I=1, LIST_BURNED%NUM_NODES)

      IF (FULL_BINARY_OUTPUTS) THEN
         WRITE(LU) (BINARY_OUTPUTS_TOA          (I), I=1, LIST_BURNED%NUM_NODES)
         WRITE(LU) (BINARY_OUTPUTS_FLAME_LENGTH (I), I=1, LIST_BURNED%NUM_NODES)
         WRITE(LU) (BINARY_OUTPUTS_VELOCITY_FPM (I), I=1, LIST_BURNED%NUM_NODES)
         WRITE(LU) (BINARY_OUTPUTS_CROWN_FIRE   (I), I=1, LIST_BURNED%NUM_NODES)
      ENDIF
      CLOSE(LU)
   ENDIF
ENDIF

CALL ACCUMULATE_CPU_USAGE(58, IT1, IT2)

IF (USE_EMBER_COUNT_BINS) THEN
   IF (ALLOCATED(EMBER_OUTPUTS_IX)) THEN
      DEALLOCATE (EMBER_OUTPUTS_IX)
      DEALLOCATE (EMBER_OUTPUTS_IY)
      DEALLOCATE (EMBER_OUTPUTS_COUNT)
   ENDIF

   ALLOCATE(EMBER_OUTPUTS_IX   (1:INT(STATS_NEMBERS(ICASE))))
   ALLOCATE(EMBER_OUTPUTS_IY   (1:INT(STATS_NEMBERS(ICASE))))
   ALLOCATE(EMBER_OUTPUTS_COUNT(1:INT(STATS_NEMBERS(ICASE))))

   ICOUNT=0
   DO IY = 1, NY
   DO IX = 1, NX
      IF (EMBER_COUNT(IX,IY) .GT. 0) THEN
         ICOUNT = ICOUNT + 1
         EMBER_OUTPUTS_IX   (ICOUNT) = IX
         EMBER_OUTPUTS_IY   (ICOUNT) = IY
         EMBER_OUTPUTS_COUNT(ICOUNT) = EMBER_COUNT(IX,IY)
         EMBER_COUNT(IX,IY) = 0
      ENDIF
   ENDDO
   ENDDO

   IF (ICOUNT .LT. INT(STATS_NEMBERS(ICASE))) THEN
      EMBER_OUTPUTS_COUNT(ICOUNT+1:) = 0
      EMBER_OUTPUTS_IX   (ICOUNT+1:) = 0
      EMBER_OUTPUTS_IY   (ICOUNT+1:) = 0
   ENDIF

ENDIF

CALL ACCUMULATE_CPU_USAGE(59, IT1, IT2)

DO I = 1, NUM_EVERTAGGED
   IX = EVERTAGGED_IX(I)
   IY = EVERTAGGED_IY(I)
   SURFACE_FIRE   (IX,IY) = 0
   TAGGED         (IX,IY) = .FALSE.
   TIME_OF_ARRIVAL(IX,IY) = -1.
   EVERTAGGED(IX,IY) = .FALSE.
   IF (RANDOM_IGNITIONS) PHIP (IX,IY) = 1
ENDDO

CALL ACCUMULATE_CPU_USAGE(60, IT1, IT2)

! Close smoke file
IF (ENABLE_SMOKE_OUTPUTS .AND. DUMP_SMOKE_OUTPUTS) THEN
   INQUIRE(UNIT=LUSMOKE+IRANK_WORLD,OPENED=LOPEN)
   IF (STATS_PM2P5_RELEASE(ICASE) .LT. PM2P5_RELEASE_MIN_FOR_OUTPUT) THEN
      IF (LOPEN) CLOSE(LUSMOKE+IRANK_WORLD,STATUS='DELETE')
   ELSE
      IF (LOPEN) CLOSE(LUSMOKE+IRANK_WORLD)
   ENDIF
ENDIF

! Close virtual station file
IF (NUM_VIRTUAL_STATIONS .GT. 0) THEN
   INQUIRE(UNIT=LUNODES+IRANK_WORLD,OPENED=LOPEN)
   IF (LOPEN) CLOSE(LUNODES+IRANK_WORLD)
ENDIF

! Deallocate linked lists
IF (LIST_TAGGED%NUM_NODES .GT.     0) THEN
   CALL TIDY(LIST_TAGGED)
   LIST_TAGGED%NUM_NODES=0
ENDIF

IF (LIST_BURNED%NUM_NODES .GT.     0) THEN
   LIST_BURNED%NUM_NODES_PREVIOUS = LIST_BURNED%NUM_NODES
   C => LIST_BURNED%HEAD
   DO I = 1, LIST_BURNED%NUM_NODES - 1
      CALL DELETE_NODE(LIST_BURNED, C)
      C => C%NEXT
   ENDDO
ENDIF

CALL ACCUMULATE_CPU_USAGE(61, IT1, IT2)

IF (LIST_SUPPRESSED%NUM_NODES .GT. 0) THEN 

   C => LIST_SUPPRESSED%HEAD
   DO I = 1, LIST_SUPPRESSED%NUM_NODES - 1
      CALL DELETE_NODE(LIST_SUPPRESSED, C)
      C => C%NEXT
   ENDDO

   LIST_SUPPRESSED%NUM_NODES=0
ENDIF

IF (SIMULATION_TSTOP_HOURS .LT. 0. ) STATS_SIMULATION_TSTOP_HOURS(ICASE) = T / 3600.
IF (ENABLE_EXTENDED_ATTACK .AND. STATS_FINAL_CONTAINMENT_FRAC(ICASE) .LT. 0.) STATS_FINAL_CONTAINMENT_FRAC(ICASE) = SUPP(IT_EA)%TARGET_CONTAINMENT

CALL ACCUMULATE_CPU_USAGE(62, IT1, IT2)

! *****************************************************************************
END SUBROUTINE LEVEL_SET_PROPAGATION
! *****************************************************************************

! *****************************************************************************
REAL FUNCTION HALF_SUPERBEE(R)
! *****************************************************************************

REAL, INTENT(IN) :: R

HALF_SUPERBEE = MAX(0.,MAX(MIN(0.5*R,1.),MIN(R,0.5)))

! *****************************************************************************
END FUNCTION HALF_SUPERBEE
! *****************************************************************************

! *****************************************************************************
SUBROUTINE TAG_BAND(NX, NY, IXLOC, IYLOC, T)
! *****************************************************************************

INTEGER, INTENT(IN) :: NX, NY, IXLOC, IYLOC
REAL, INTENT(IN) :: T
INTEGER :: IXTAGSTART, IXTAGSTOP, IYTAGSTART, IYTAGSTOP, IX, IY

IXTAGSTART = MAX(3,    IXLOC - BANDTHICKNESS) 
IXTAGSTOP  = MIN(NX-2, IXLOC + BANDTHICKNESS)
IYTAGSTART = MAX(3,    IYLOC - BANDTHICKNESS) 
IYTAGSTOP  = MIN(NY-2, IYLOC + BANDTHICKNESS)

DO IY = IYTAGSTART, IYTAGSTOP
DO IX = IXTAGSTART, IXTAGSTOP
   IF (ISNONBURNABLE(IX,IY)) CYCLE
   IF (.NOT. TAGGED(IX,IY) .AND. (.NOT. EVERTAGGED(IX,IY)) ) THEN 
      TAGGED    (IX,IY) = .TRUE.
      EVERTAGGED(IX,IY) = .TRUE.
      CALL APPEND(LIST_TAGGED, IX, IY, T)
      NUM_EVERTAGGED = NUM_EVERTAGGED + 1
      EVERTAGGED_IX(NUM_EVERTAGGED) = IX
      EVERTAGGED_IY(NUM_EVERTAGGED) = IY
   ENDIF
ENDDO
ENDDO

! *****************************************************************************
END SUBROUTINE TAG_BAND
! *****************************************************************************

! *****************************************************************************
SUBROUTINE UNTAG_CELLS(NX, NY, TOA, T, BURNED)
! *****************************************************************************

TYPE(NODE), POINTER :: C => NULL()

INTEGER, INTENT(IN) :: NX, NY
INTEGER :: IXLO,IXHI,IYLO,IYHI
REAL, INTENT(IN) :: TOA(:,:), T
INTEGER*2, INTENT(IN) :: BURNED(:,:)
LOGICAL :: UNTAG_BECAUSE_BURNED

INTEGER :: I, IX, IY, IX1, IX2, IY1, IY2, IXSTART, IXSTOP, IYSTART, IYSTOP, NUM_DELETED=0

IF (LIST_TAGGED%NUM_NODES .EQ. 0) RETURN
IXLO = NX
IXHI = 1
IYLO = NY
IYHI = 1
NUM_DELETED = 0

!WRITE(*,*) 'LIST_TAGGED%NUM_NODES BEFORE DELETING: ', LIST_TAGGED%NUM_NODES
C=>LIST_TAGGED%HEAD
I = 0
DO
   IF (LIST_TAGGED%NUM_NODES .LE. 0) EXIT
   IF (.NOT. ASSOCIATED(C)) EXIT
   I = I + 1
   IX = C%IX
   IY = C%IY

! Remove cells that have been tagged for more than 1 week:
   IF (PHIP(IX,IY) .GE. 0. .AND. C%TIME_ADDED .GT. 0. .AND. T - C%TIME_ADDED .GT. 604800. ) THEN 
      C%TIME_SUPPRESSED = T
      NUM_DELETED = NUM_DELETED + 1
      CALL DELETE_NODE(LIST_TAGGED, C)
      TAGGED(IX,IY) = .FALSE.
      C => C%NEXT
      CYCLE
   ENDIF

! Remove single isolated tagged pixels:
   IX1 = MAX(1, IX-1)
   IF (.NOT. TAGGED(IX1,IY) ) THEN
      IX2 = MIN(NX, IX+1) 
      IF (.NOT. TAGGED(IX2,IY) ) THEN
         IY1 = MAX(1, IY-1) 
         IF (.NOT. TAGGED(IX,IY1)) THEN
            IY2 = MIN(NY, IY+1)
            IF (.NOT. TAGGED(IX,IY2)) THEN
               C%TIME_SUPPRESSED = T
               NUM_DELETED = NUM_DELETED + 1
               CALL DELETE_NODE(LIST_TAGGED, C)
               TAGGED(IX,IY) = .FALSE.
               C => C%NEXT
               CYCLE
            ENDIF
         ENDIF
      ENDIF
   ENDIF

   IXSTART = MAX(1 , IX - BANDTHICKNESS) ; IXSTART = MIN(IXSTART,NX)
   IXSTOP  = MIN(NX, IX + BANDTHICKNESS) ; IXSTOP  = MAX(IXSTOP , 1)
   IYSTART = MAX(1 , IY - BANDTHICKNESS) ; IYSTART = MIN(IYSTART,NY)
   IYSTOP  = MIN(NY, IY + BANDTHICKNESS) ; IYSTOP  = MAX(IYSTOP , 1)

   UNTAG_BECAUSE_BURNED = .TRUE.
   DO IX2 = IXSTART, IXSTOP
      IF (PHIP(IX2,IY) .GE. 0.) UNTAG_BECAUSE_BURNED = .FALSE.
   ENDDO
   DO IY2 = IYSTART, IYSTOP
      IF (PHIP(IX,IY2) .GE. 0.) UNTAG_BECAUSE_BURNED = .FALSE.
   ENDDO

   IF ((.NOT. UNTAG_BECAUSE_BURNED) .AND. UNTAG_TYPE_2) THEN
!      IF ( TOA(IX,IY) .GT. 0. .AND. T - TOA(IX,IY) .GT. 20*DT ) UNTAG_BECAUSE_BURNED = .TRUE. 
      IF ( TOA(IX,IY) .GT. 0. .AND. T - TOA(IX,IY) .GT. 72000. ) UNTAG_BECAUSE_BURNED = .TRUE. 
   ENDIF

   IF ((.NOT. UNTAG_BECAUSE_BURNED) .AND. UNTAG_TYPE_3) THEN
      IF ( PHIP(IX,IY) .LT. -0.9999 .AND. BURNED(IX,IY) .EQ. 1 ) UNTAG_BECAUSE_BURNED = .TRUE. 
   ENDIF

   IF (UNTAG_BECAUSE_BURNED) THEN
      PHIP(IX,IY) = -1E0
      NUM_DELETED = NUM_DELETED + 1
      CALL DELETE_NODE(LIST_TAGGED, C)
      TAGGED(IX,IY) = .FALSE.
   ENDIF

   IF (C%TIME_SUPPRESSED .GT. 0.) THEN
      CALL APPEND(LIST_SUPPRESSED, IX, IY, T)
!      LIST_SUPPRESSED%TAIL = C
      NUM_DELETED = NUM_DELETED + 1
      CALL DELETE_NODE(LIST_TAGGED, C)
      TAGGED(IX,IY) = .FALSE.
   ENDIF

   C => C%NEXT    

ENDDO

! *****************************************************************************
END SUBROUTINE UNTAG_CELLS
! *****************************************************************************

! *****************************************************************************
SUBROUTINE CALC_NORMAL_VECTORS(ISTEP, HALFRCELLSIZE)
! *****************************************************************************

INTEGER, INTENT(IN) :: ISTEP
INTEGER :: I, IX, IY
REAL :: HALFRCELLSIZE, DPHIDX, DPHIDY, RMAGGRADPHI
TYPE(NODE), POINTER :: C
REAL, PARAMETER :: EPSILON = 1E-30, BIG=3E4

C => LIST_TAGGED%HEAD
IF (ISTEP .EQ. 1) THEN
   DO I = 1, LIST_TAGGED%NUM_NODES
      IX=C%IX
      IY=C%IY
      C%PHIP_OLD = PHIP(IX,IY)
      DPHIDY = MAX(MIN( HALFRCELLSIZE * (PHIP(IX,IY+1) - PHIP(IX,IY-1)), BIG ), -BIG)
      DPHIDX = MAX(MIN( HALFRCELLSIZE * (PHIP(IX+1,IY) - PHIP(IX-1,IY)), BIG ), -BIG)
      RMAGGRADPHI = 1. / MAX(SQRT( DPHIDX * DPHIDX + DPHIDY * DPHIDY ), EPSILON)
      C%NORMVECTORY = RMAGGRADPHI * DPHIDY
      C%NORMVECTORX = RMAGGRADPHI * DPHIDX
      C => C%NEXT
   ENDDO

ELSE
   DO I = 1, LIST_TAGGED%NUM_NODES
      IX=C%IX
      IY=C%IY
      DPHIDX = MAX(MIN( HALFRCELLSIZE * (PHIP(IX+1,IY) - PHIP(IX-1,IY)), BIG ), -BIG)
      DPHIDY = MAX(MIN( HALFRCELLSIZE * (PHIP(IX,IY+1) - PHIP(IX,IY-1)), BIG ), -BIG)
      RMAGGRADPHI = 1. / MAX(SQRT( DPHIDX * DPHIDX + DPHIDY * DPHIDY ), EPSILON)
      C%NORMVECTORX = RMAGGRADPHI * DPHIDX
      C%NORMVECTORY = RMAGGRADPHI * DPHIDY
      C => C%NEXT
   ENDDO

ENDIF

! *****************************************************************************
END SUBROUTINE CALC_NORMAL_VECTORS
! *****************************************************************************

! *****************************************************************************
SUBROUTINE UX_AND_UY_ELLIPTICAL(L, LB, ACCELERATION_FACTOR, ISTEP, T_ELMFIRE, DYNAMIC_ARRAY)
! *****************************************************************************
! Parameter T_ELMFIRE added to update fireline intensity of structures over time
REAL, INTENT(IN) :: ACCELERATION_FACTOR, T_ELMFIRE
TYPE(DLL), INTENT(INOUT) :: L, LB
INTEGER, INTENT(IN) :: ISTEP
TYPE(NODE), POINTER :: C, LB_P

REAL, ALLOCATABLE, INTENT(INOUT), DIMENSION(:,:) :: DYNAMIC_ARRAY  ! Dynamic array to store IX and IY


REAL :: PHIMAG, PHIWX, PHIWY, PHIX, PHIY, WSMFEFF, A, B, COSANG, SINANG, BOH, DXDT, DYDT, DENOM, &
        DXDT_ROTATED, DYDT_ROTATED, AACOSANG, BBSINANG, APHIS, APHIW, SINASPMPI, COSASPMPI, &
        RPHIMAG, RDENOM, SQRT_LOW2_M1!, STRUCTURE_AREA
INTEGER :: IASP, I, ILH, NITER
REAL, PARAMETER :: KWPM2_TO_BTUPFT2MIN = 60. * 0.3048 * 0.3048 / 1.055, FTPMIN_TO_MPS = 0.3048 / 60.
LOGICAL :: DONE, CROWN_FIRE_AT_START, CROWN_FIRE_AT_END

C => L%HEAD

IF (USE_BLDG_SPREAD_MODEL .AND. (BLDG_SPREAD_MODEL_TYPE .EQ. 2)) THEN
   LB_P => LB%HEAD

   DO I = 1, LB%NUM_NODES
      CALL ELLIPSE_UCB(LB_P)
      CALL HRR_TRANSIENT(LB_P, T_ELMFIRE)
      LB_P%FLIN_SURFACE = LB_P%HRR_TRANSIENT*ANALYSIS_CELLSIZE ! kW/m
      LB_P => LB_P%NEXT
   ENDDO
ENDIF

IF (ISTEP .EQ. 1) THEN
   DO I = 1, L%NUM_NODES

      IF (.NOT. C%BURNED) THEN

         IF (C%NEED_SLOPE_CALC) THEN
! Determine individual slope and wind components and velocity in direction of maximum spread (DMS):
            IASP=MIN(MAX(NINT(ASP%R4(C%IX,C%IY,1)),0),360)
            SINASPMPI=SINASPM180(IASP)
            COSASPMPI=COSASPM180(IASP) 
            APHIS = ACCELERATION_FACTOR * PHIS_ADJ * C%PHIS_SURFACE
            C%PHISX = APHIS * SINASPMPI
            C%PHISY = APHIS * COSASPMPI
            C%UXOUSX = 1. - ABSSINASP(IASP) * OMCOSSLPRAD%R4(C%IX,C%IY,1)
            C%UYOUSY = 1. - ABSCOSASP(IASP) * OMCOSSLPRAD%R4(C%IX,C%IY,1)
            C%NEED_SLOPE_CALC = .FALSE.
         ENDIF

         DONE = .FALSE.
         NITER = 0
         DO WHILE (.NOT. DONE)
            CROWN_FIRE_AT_START = .FALSE.
            IF (CROWN_FIRE_MODEL .GT. 0 .AND. C%FLIN_SURFACE .GE. C%CRITICAL_FLIN) THEN
               APHIW = PHIW_ADJ * MAX(C%PHIW_SURFACE, C%PHIW_CROWN)
               CROWN_FIRE_AT_START = .TRUE.
            ELSE
               APHIW = PHIW_ADJ * ACCELERATION_FACTOR * C%PHIW_SURFACE
            ENDIF

            IF (USE_BLDG_SPREAD_MODEL .AND. C%IFBFM .EQ. 91) THEN
               APHIW   = 1.0
               C%PHISX = 0.0
               C%PHISY = 0.0
            ENDIF

            PHIWX = APHIW * SIN( (C%WD20_NOW - 180.) * PIO180)
            PHIX  = C%PHISX + PHIWX

            PHIWY = APHIW * COS( (C%WD20_NOW - 180.) * PIO180)
            PHIY  = C%PHISY + PHIWY

            PHIMAG = MAX(SQRT(PHIX*PHIX+PHIY*PHIY),1E-10)
            IF (PHIMAG .LT. 1.1E-10) THEN
               C%NORMVECTORX_DMS  = 1.0
               C%NORMVECTORY_DMS  = 0.0
            ELSE
               RPHIMAG = 1. / PHIMAG
               C%NORMVECTORX_DMS = RPHIMAG * PHIX
               C%NORMVECTORY_DMS = RPHIMAG * PHIY
            ENDIF
            C%VELOCITY_DMS = C%VS0 * (ACCELERATION_FACTOR + PHIMAG)

! Determine effective mid flame wind speed
            WSMFEFF = FUEL_MODEL_TABLE_2D(C%IFBFM,30)%WSMFEFF_COEFF * PHIMAG ** FUEL_MODEL_TABLE_2D(C%IFBFM,30)%B_COEFF_INVERSE
            IF (C%FLIN_SURFACE .LT. C%CRITICAL_FLIN .OR. CROWN_FIRE_MODEL .LE. 0) WSMFEFF = MIN(WSMFEFF, 0.9*KWPM2_TO_BTUPFT2MIN*C%IR)

! Calculate length over width:
            C%LOW = MIN( 0.936*EXP(0.2566*WSMFEFF*WSMFEFF_LOW_MULT) + 0.461*EXP(-0.1548*WSMFEFF*WSMFEFF_LOW_MULT) - 0.397, MAX_LOW)
            IF (C%LOW .GT. 0.999 .AND. C%LOW .LT. 1.001) THEN
               BOH = 1.0
            ELSE
               SQRT_LOW2_M1 = SQRT(C%LOW*C%LOW - 1.0)
               BOH = (C%LOW - SQRT_LOW2_M1) / (C%LOW + SQRT_LOW2_M1 )
            ENDIF
            C%VBACK = BOH * C%VELOCITY_DMS

            IF (USE_BLDG_SPREAD_MODEL .AND. C%IFBFM .EQ. 91) THEN
               CONTINUE
               IF (BLDG_SPREAD_MODEL_TYPE .EQ. 1) CALL HAMADA(C) ! GET C%VELOCITY_DMS, C%VBACK & C%LOW
               IF (BLDG_SPREAD_MODEL_TYPE .EQ. 2) CALL UMD_UCB_BLDG_SPREAD(C, LB, T_ELMFIRE, DYNAMIC_ARRAY) ! GET C%VELOCITY_DMS, C%VBACK & C%LOW
               CONTINUE
            ENDIF

! We can get sin(theta - dms) and cos(theta - dms) directly:
            COSANG   = C%NORMVECTORY*C%NORMVECTORY_DMS + C%NORMVECTORX*C%NORMVECTORX_DMS
            A        = MAX(0.5 * (C%VELOCITY_DMS + C%VBACK), 1E-10)
            AACOSANG = A*A*COSANG

            SINANG   = C%NORMVECTORX*C%NORMVECTORY_DMS - C%NORMVECTORY*C%NORMVECTORX_DMS
            B        = 0.5 * MAX( (C%VELOCITY_DMS + C%VBACK) / C%LOW, 1E-10)
            BBSINANG = B*B*SINANG

            DENOM    = MAX(SQRT(AACOSANG*COSANG + BBSINANG*SINANG),1E-10)
            RDENOM   = 1. / DENOM

            DYDT     = (RDENOM * AACOSANG ) + 0.5 * (C%VELOCITY_DMS - C%VBACK)
            DXDT     = RDENOM * BBSINANG 

! Rotate based on direction of maximum spread:
            DXDT_ROTATED = DYDT*C%NORMVECTORX_DMS + DXDT*C%NORMVECTORY_DMS !ft/min, parallel to slope
            C%UX = DXDT_ROTATED * C%UXOUSX * FTPMIN_TO_MPS !m/s, projected

            DYDT_ROTATED = DYDT*C%NORMVECTORY_DMS - DXDT*C%NORMVECTORX_DMS !ft/min, parallel to slope
            C%UY = DYDT_ROTATED * C%UYOUSY * FTPMIN_TO_MPS !m/s, projected

            C%VELOCITY = SQRT(DXDT_ROTATED*DXDT_ROTATED + DYDT_ROTATED*DYDT_ROTATED) ! ft/min, parallel to slope

            ILH = MAX(MIN(NINT(100.*C%MLH),120),30)
            C%FLIN_SURFACE = FUEL_MODEL_TABLE_2D(C%IFBFM,ILH)%TR * C%IR * C%VELOCITY * 0.3048 ! kW/m

            IF (NO_SURFACE_FIRE) THEN
               C%UX = 1E-5
               C%UY = 1E-5
            ENDIF

            CROWN_FIRE_AT_END = .FALSE.
            IF (CROWN_FIRE_MODEL .GT. 0 .AND. C%FLIN_SURFACE .GE. C%CRITICAL_FLIN) CROWN_FIRE_AT_END = .TRUE.

            DONE = .TRUE.
            IF (CROWN_FIRE_AT_END .AND. (.NOT. CROWN_FIRE_AT_START)) DONE = .FALSE.
            NITER = NITER + 1
            IF (NITER .EQ. 2) DONE = .TRUE. !Prevent infinite loop if something goes awry
         ENDDO

      ENDIF
      C => C%NEXT

   ENDDO

ELSE !ISTEP .EQ. 2

   DO I = 1, L%NUM_NODES
      IF (.NOT. C%BURNED) THEN
         CONTINUE

! We can get sin(theta - dms) and cos(theta - dms) directly:
         COSANG   = C%NORMVECTORY*C%NORMVECTORY_DMS + C%NORMVECTORX*C%NORMVECTORX_DMS
         A        = MAX(0.5 * (C%VELOCITY_DMS + C%VBACK), 1E-10)
         AACOSANG = A*A*COSANG

         SINANG   = C%NORMVECTORX*C%NORMVECTORY_DMS - C%NORMVECTORY*C%NORMVECTORX_DMS
         B        = 0.5 * MAX( (C%VELOCITY_DMS + C%VBACK) / C%LOW, 1E-10)
         BBSINANG = B*B*SINANG

         DENOM    = MAX(SQRT(AACOSANG*COSANG + BBSINANG*SINANG),1E-10)
         RDENOM   = 1. / DENOM

         DYDT     = (RDENOM * AACOSANG ) + 0.5 * (C%VELOCITY_DMS - C%VBACK)
         DXDT     = RDENOM * BBSINANG 

! Rotate based on direction of maximum spread:
         DXDT_ROTATED = DYDT*C%NORMVECTORX_DMS + DXDT*C%NORMVECTORY_DMS !ft/min, parallel to slope
         C%UX = DXDT_ROTATED * C%UXOUSX * FTPMIN_TO_MPS !m/s, projected

         DYDT_ROTATED = DYDT*C%NORMVECTORY_DMS - DXDT*C%NORMVECTORX_DMS !ft/min, parallel to slope
         C%UY = DYDT_ROTATED * C%UYOUSY * FTPMIN_TO_MPS !m/s, projected

         C%VELOCITY = SQRT(DXDT_ROTATED*DXDT_ROTATED + DYDT_ROTATED*DYDT_ROTATED) ! ft/min, parallel to slope

         ILH = MAX(MIN(NINT(100.*C%MLH),120),30)
         C%FLIN_SURFACE = FUEL_MODEL_TABLE_2D(C%IFBFM,ILH)%TR * C%IR * C%VELOCITY * 0.3048 ! kW/m
         IF (NO_SURFACE_FIRE) THEN
               C%UX = 1E-5
               C%UY = 1E-5
         ENDIF

         IF (CROWN_FIRE_MODEL .GT. 0 .AND. C%FLIN_SURFACE .GE. C%CRITICAL_FLIN) C%FLIN_CANOPY = C%HPUA_CANOPY * C%VELOCITY * 5.08E-3

         IF (USE_UMD_SPOTTING_MODEL .AND. USE_PHYSICAL_SPOTTING_DURATION) C%LOCAL_EMBERGEN_DURATION = FUEL_MODEL_TABLE_2D(C%IFBFM,ILH)%TR*60.0 ! min to second
         
              
         IF (USE_BLDG_SPREAD_MODEL .AND. BLDG_SPREAD_MODEL_TYPE .EQ. 2 .AND. C%IFBFM .EQ. 91) THEN
            C%FLIN_SURFACE = 0.0 ! kW/m
         ENDIF
         IF (USE_BLDG_SPREAD_MODEL .AND. BLDG_SPREAD_MODEL_TYPE .EQ. 1 .AND. C%IFBFM .EQ. 91) THEN
            C%FLIN_SURFACE = 4000.0 ! kW/m
         ENDIF

      ! ELSE
      !    IF (USE_BLDG_SPREAD_MODEL .AND. (BLDG_SPREAD_MODEL_TYPE .EQ. 2) .AND. (C%IFBFM .EQ. 91)) THEN
      !       CALL HRR_TRANSIENT(C, T_ELMFIRE)
      !       C%FLIN_SURFACE = C%HRR_TRANSIENT*ANALYSIS_CELLSIZE ! kW/m
      !    ENDIF

      ENDIF
      ! IF (USE_UMD_SPOTTING_MODEL .AND. USE_PHYSICAL_SPOTTING_DURATION) THEN
      !    IF (C%IFBFM .EQ. 91) THEN
      !       ! This is to account the emitting duration of structures
      !       STRUCTURE_AREA = CC%CELLSIZE * CC%CELLSIZE * C%BLDG_FOOTPRINT_FRAC
      !       ! This subroutine locates in module "elmfire_spotting"
      !       CALL STRUCTURE_DESIGN_FIRE_CURVE(C, STRUCTURE_AREA, T_ELMFIRE)
      !    ENDIF
      ! ENDIF

      ! This is the best place to retrieve C%HRR_TRANSIENT for the output raster
      
      C => C%NEXT

   ENDDO

ENDIF !ISTEP .EQ. 1

! *****************************************************************************
END SUBROUTINE UX_AND_UY_ELLIPTICAL
! *****************************************************************************

! *****************************************************************************
SUBROUTINE CALC_CFL(DT)
! *****************************************************************************

REAL, INTENT(INOUT) :: DT
INTEGER :: I
REAL :: CFL, U, UX, UY, UMAX
TYPE(NODE), POINTER :: C

UMAX = 0.
C => LIST_TAGGED%HEAD
DO I = 1, LIST_TAGGED%NUM_NODES
   IF (.NOT. C%BURNED) THEN
      UX=ABS(C%UX)
      UY=ABS(C%UY)
      U=MAX(UX,UY)
      IF (U .GT. UMAX) UMAX = U
   ENDIF
   C => C%NEXT
ENDDO

CFL = UMAX * DT / ANALYSIS_CELLSIZE
IF (CFL .GT. 0.) THEN
   DT = MIN(TARGET_CFL * DT / CFL, SIMULATION_DTMAX)
ELSE
   DT = SIMULATION_DTMAX
ENDIF
CONTINUE

! *****************************************************************************
END SUBROUTINE CALC_CFL
! *****************************************************************************

! *****************************************************************************
SUBROUTINE RK2_INTEGRATE(DT,ISTEP)
! *****************************************************************************

REAL, INTENT(IN) :: DT
INTEGER, INTENT(IN) :: ISTEP
INTEGER :: I
TYPE(NODE), POINTER :: C

! 2nd order Runge Kutta integration:
C => LIST_TAGGED%HEAD
IF (ISTEP .EQ. 1) THEN
   DO I = 1, LIST_TAGGED%NUM_NODES
      PHIP(C%IX,C%IY) = C%PHIP_OLD - DT * (C%UX * C%DPHIDX_LIMITED + C%UY * C%DPHIDY_LIMITED)
      IF ( PHIP(C%IX,C%IY) .NE. PHIP(C%IX,C%IY)) PHIP(C%IX,C%IY) = 1.0
      IF ( PHIP(C%IX,C%IY) .LT. -100.0 ) PHIP(C%IX,C%IY) = -100.0
      IF ( PHIP(C%IX,C%IY) .GT.  100.0 ) PHIP(C%IX,C%IY) =  100.0
      C => C%NEXT
   ENDDO
ELSE
   DO I = 1, LIST_TAGGED%NUM_NODES
      PHIP(C%IX,C%IY) = 0.5 * (C%PHIP_OLD + (PHIP(C%IX,C%IY) - DT * (C%UX * C%DPHIDX_LIMITED + C%UY * C%DPHIDY_LIMITED )))
      C => C%NEXT
   ENDDO
ENDIF

! *****************************************************************************
END SUBROUTINE RK2_INTEGRATE
! *****************************************************************************

! *****************************************************************************
SUBROUTINE LIMIT_GRADIENTS(RCELLSIZE,PHI)
! *****************************************************************************

REAL, INTENT(IN) :: RCELLSIZE
REAL, DIMENSION(:,:), INTENT(IN) :: PHI

INTEGER :: I
REAL :: DELTAUP, DELTALOC, PHIEAST=1.0, PHIWEST=1.0, PHINORTH=1.0, PHISOUTH=1.0
REAL, PARAMETER :: EPSILON = 1E-30
REAL, PARAMETER :: CEILING = 1E3
TYPE(NODE), POINTER :: C

C => LIST_TAGGED%HEAD
DO I = 1, LIST_TAGGED%NUM_NODES
         
   IF (C%UX .GE. 0E0) THEN

! PHIEAST
      DELTAUP  = PHI(C%IX,  C%IY) - PHI(C%IX-1,C%IY)
      DELTALOC = PHI(C%IX+1,C%IY) - PHI(C%IX  ,C%IY)
      IF (ABS(DELTALOC) > EPSILON) PHIEAST = PHI(C%IX,C%IY) + HALF_SUPERBEE(DELTAUP / DELTALOC)*DELTALOC

! PHIWEST
      DELTALOC = -DELTAUP
      IF (ABS(DELTALOC) > EPSILON) THEN
         DELTAUP = PHI(C%IX-2,C%IY) - PHI(C%IX-1,C%IY)
         PHIWEST = PHI(C%IX-1,C%IY) - HALF_SUPERBEE(DELTAUP / DELTALOC)*DELTALOC
      ENDIF

   ELSE ! UX .LT. 0

! PHIEAST
      DELTALOC = PHI(C%IX+1,C%IY) - PHI(C%IX, C%IY)      
      IF (ABS(DELTALOC) > EPSILON) THEN    
         DELTAUP  = PHI(C%IX+2,C%IY) - PHI(C%IX+1,C%IY)
         PHIEAST = PHI(C%IX+1,C%IY) - HALF_SUPERBEE(DELTAUP / DELTALOC)*DELTALOC
      ENDIF

! PHIWEST
      DELTAUP  = -DELTALOC
      DELTALOC = PHI(C%IX-1,C%IY) - PHI(C%IX,C%IY)
      IF (ABS(DELTALOC) > EPSILON) PHIWEST = PHI(C%IX,C%IY)+ HALF_SUPERBEE(DELTAUP / DELTALOC)*DELTALOC

   ENDIF

   C%DPHIDX_LIMITED = (PHIEAST  - PHIWEST) * RCELLSIZE

   IF (C%UY .GT. 0E0) THEN

! PHINORTH
      DELTAUP  = PHI(C%IX,C%IY) - PHI(C%IX,C%IY-1)
      DELTALOC = PHI(C%IX,C%IY+1) - PHI(C%IX,C%IY)      
      IF (ABS(DELTALOC) > EPSILON) PHINORTH = PHI(C%IX,C%IY) + HALF_SUPERBEE(DELTAUP / DELTALOC)*DELTALOC

! PHISOUTH
      DELTALOC = -DELTAUP      
      IF (ABS(DELTALOC) .GT. EPSILON) THEN
         DELTAUP  = PHI(C%IX,C%IY-2) - PHI(C%IX,C%IY-1)
         PHISOUTH = PHI(C%IX,C%IY-1) - HALF_SUPERBEE(DELTAUP / DELTALOC)*DELTALOC
      ENDIF

   ELSE !UY .LT. 0

! PHINORTH
      DELTALOC = PHI(C%IX,C%IY+1) - PHI(C%IX,C%IY  )
      IF (ABS(DELTALOC) > EPSILON) THEN
         DELTAUP  = PHI(C%IX,C%IY+2) - PHI(C%IX,C%IY+1)
         PHINORTH = PHI(C%IX,C%IY+1) - HALF_SUPERBEE(DELTAUP / DELTALOC)*DELTALOC
      ENDIF

! PHISOUTH
      DELTAUP  = -DELTALOC
      DELTALOC = PHI(C%IX,C%IY-1) - PHI(C%IX,C%IY)
      IF (ABS(DELTALOC) > EPSILON) PHISOUTH = PHI(C%IX,C%IY) + HALF_SUPERBEE(DELTAUP / DELTALOC)*DELTALOC

   ENDIF

   C%DPHIDY_LIMITED = (PHINORTH - PHISOUTH) * RCELLSIZE

   IF (C%DPHIDX_LIMITED .GT.  CEILING) C%DPHIDX_LIMITED = CEILING
   IF (C%DPHIDY_LIMITED .GT.  CEILING) C%DPHIDY_LIMITED = CEILING

   IF (C%DPHIDX_LIMITED .LT. -CEILING) C%DPHIDX_LIMITED = -CEILING
   IF (C%DPHIDY_LIMITED .LT. -CEILING) C%DPHIDY_LIMITED = -CEILING

   IF (C%DPHIDX_LIMITED .NE.  C%DPHIDX_LIMITED) C%DPHIDX_LIMITED = 0.
   IF (C%DPHIDY_LIMITED .NE.  C%DPHIDY_LIMITED) C%DPHIDY_LIMITED = 0.

   C => C%NEXT

ENDDO !I=1, LIST_TAGGED%NUM_NODES

! *****************************************************************************
END SUBROUTINE LIMIT_GRADIENTS
! *****************************************************************************

! *****************************************************************************
END MODULE
! *****************************************************************************
